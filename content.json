{"meta":{"title":"Mr.Az 的 secret base","subtitle":"","description":"Volantis 是一个功能丰富、高度模块化的 Hexo 博客主题。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的博客，也可以仿照官网搭建一个多人协作的、包含文档模块的大体量综合型博客。","author":"Mr.Az","url":"https://volantis.js.org","root":"/"},"pages":[{"title":"","date":"2025-05-22T05:13:04.185Z","updated":"2025-05-22T05:13:01.033Z","comments":true,"path":"404.html","permalink":"https://volantis.js.org/404","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-05-26T05:14:29.595Z","updated":"2025-05-26T05:14:29.595Z","comments":true,"path":"headBegin.html","permalink":"https://volantis.js.org/headBegin","excerpt":"","text":""},{"title":"","date":"2025-05-16T08:23:20.353Z","updated":"2025-05-16T08:23:20.353Z","comments":true,"path":"about/index.html","permalink":"https://volantis.js.org/about/","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2025-05-16T08:23:44.650Z","updated":"2025-05-16T08:23:44.650Z","comments":true,"path":"categories/index.html","permalink":"https://volantis.js.org/categories/","excerpt":"","text":""},{"title":"友链","date":"2025-05-23T04:59:19.479Z","updated":"2025-05-23T04:59:19.479Z","comments":true,"path":"friends/index.html","permalink":"https://volantis.js.org/friends/","excerpt":"欢迎交换友链。 以下的人，在我的人生中成为了不可分割的一部分，为我的人生需写了一段精彩。","text":"欢迎交换友链。 以下的人，在我的人生中成为了不可分割的一部分，为我的人生需写了一段精彩。"},{"title":"","date":"2025-05-16T08:24:27.178Z","updated":"2025-05-16T08:24:27.178Z","comments":true,"path":"mylist/index.html","permalink":"https://volantis.js.org/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2025-05-16T08:24:05.432Z","updated":"2025-05-16T08:24:05.432Z","comments":true,"path":"tags/index.html","permalink":"https://volantis.js.org/tags/","excerpt":"","text":""}],"posts":[{"title":"题解：ABC292Ex Rating Estimator","slug":"题解：ABC292Ex Rating Estimator","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：ABC292Ex Rating Estimator/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AABC292Ex%20Rating%20Estimator/","excerpt":"","text":"Question 问题 ABC292Ex Rating Estimator 题目大意： 给定一个长度为 nnn 的序列 {ai}\\{a_i\\}{ai​}，参数 BBB，询问数 qqq； 每一次单点修改后，输出你当前的 rating，其计算方法如下分两种情况讨论: 如果不存在某一个前缀平均值不低于 BBB，则输出整体平均值； 否则，输出第一个不低于 BBB 的前缀平均值。 Solution 线段树二分 对于这种维护平均值的题目，有一个方法就是我们将所有的数减去 BBB 后，这个问题转移成为了寻找第一个前缀和非负的区间。考虑使用线段树维护前缀和。 最终的答案是最前的非负前缀和，线段树维护前缀最大即可。对于每一次的单点修改可以转化为区间修改，因为该点的影响只对其后的位置的前缀和有影响。 对于第一种情况，只需要在这之后通过线段树上二分找到该位置计算答案即可。 对于第二种情况，只需要维护当前的数组 {ai}\\{a_i\\}{ai​} 的总和即可。 判断这两种情况也只需要看 [1,n][1,n][1,n] 中的最大值，具体看代码。 时间复杂度：O(nlog⁡n+qlog⁡n)O(n \\log n+q \\log n)O(nlogn+qlogn)，前者是建树的复杂度，后者是查询的复杂度。 Code 代码 struct tree&#123; int val,lazy; #define mx(p) t[p].val #define lazy(p) t[p].lazy&#125;t[N*8];inline void update(int p)&#123;mx(p)=max(mx(ls),mx(rs));&#125;void build(int p,int l,int r)&#123; t[p]=&#123;0,0&#125;; if(l==r)&#123;mx(p)=sum[l];return ;&#125;//维护前缀和 int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); update(p);&#125;void spread(int p)&#123; if(lazy(p))&#123; int tt=lazy(p); lazy(ls)+=tt;lazy(rs)+=tt; mx(ls)+=tt; mx(rs)+=tt; lazy(p)=0; &#125; return ;&#125;void change(int p,int l,int r,int L,int R,int k)&#123;//区间修改 if(L&lt;=l&amp;&amp;r&lt;=R)&#123;mx(p)+=k;lazy(p)+=k;return ;&#125; int mid=l+r&gt;&gt;1; spread(p); if(L&lt;=mid) change(ls,l,mid,L,R,k); if(R&gt;mid) change(rs,mid+1,r,L,R,k); update(p);&#125;void ask(int p,int l,int r)&#123; if(l==r)&#123;ans=(1.0*mx(p)+l*b)/l;return ;&#125; spread(p); int mid=l+r&gt;&gt;1; if(mx(ls)&gt;=0) ask(ls,l,mid);//线段树上二分 else ask(rs,mid+1,r);//线段树上二分&#125;signed main()&#123; read(n,b,q); for(rint i=1;i&lt;=n;i++) read(a[i]),sum[i]=sum[i-1]+a[i]-b,res+=a[i];//处理前缀和 build(1,1,n); while(q--)&#123; int c,x;read(c,x);res+=x-a[c]; change(1,1,n,c,n,x-a[c]);//只需要向[c,n]的后缀加上修改的值 a[c]=x; if(mx(1)&lt;0) printf(&quot;%.15lf\\n&quot;,1.0*res/n);//不存在非负区间，直接输出答案 else&#123; ask(1,1,n); printf(&quot;%.15lf\\n&quot;,ans); &#125; &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"线段树二分","slug":"线段树二分","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BA%8C%E5%88%86/"}],"author":"Mr.Az"},{"title":"题解：CF1270F Awesome Substrings","slug":"题解：CF1270F Awesome Substrings","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：CF1270F Awesome Substrings/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF1270F%20Awesome%20Substrings/","excerpt":"","text":"Question 问题 CF1270F Awesome Substrings 基本信息： 知识点：根号分块 题目大意： 给定一个长度为 nnn 的 01 串 sss。 求有多少个区间 [l,r][l,r][l,r] 满足 r−l+1r-l+1r−l+1 是 sl...rs_{l...r}sl...r​ 中 111 的个数的倍数。 Solution 根号分块 根据套路，我们将这个问题分为两块来处理，分别是 k≤nk \\le \\sqrt{n}k≤n​ 和 k&gt;nk &gt; \\sqrt{n}k&gt;n​ 。 我们令 cntnumcnt_{num}cntnum​ 代表一段区间内 numnumnum 的个数，posipos_iposi​ 为第 ith 1i_{th}~1ith​ 1 的下标 。 枚举倍数 kkk 使得 k×cnt1=cnt1+cnt0k \\times cnt_1 = cnt_1 + cnt_0k×cnt1​=cnt1​+cnt0​ k≤nk \\le \\sqrt{n}k≤n​ 问题可以看作已知倍数 kkk 求满足 k×cnt1=cnt1+cnt0k \\times cnt_1 = cnt_1 + cnt_0k×cnt1​=cnt1​+cnt0​ 的区间个数。这种问题有一种方法就是给两个数赋值。 我们计算一下这个式子，(k−1)×cnt1−cnt0=0(k-1) \\times cnt_1 - cnt_0 = 0(k−1)×cnt1​−cnt0​=0，相当于给 111 赋值为 k−1k-1k−1，000 赋值为 −1-1−1，在满足上述式子的前提下怎样分配权值都是可以的。 所以做一个前缀和，开个桶记录合法情况个数。（unordered_map 好像会超时，直接用数组，数据范围不大） k&gt;nk &gt; \\sqrt{n}k&gt;n​ 此时 111 的个数很少，上界为 n\\sqrt{n}n​。考虑直接枚举 111 的个数 cntcntcnt，再枚举一个左端点 lll，右端点 rrr 的范围就可以通过 111 的位置夹住算出来，令范围为 [rl,rr][r_l,r_r][rl​,rr​]，贡献为 ⌊rr−l+1cnt⌋−max⁡(n,⌊rl−lcnt⌋)\\lfloor \\frac{r_r-l+1}{cnt} \\rfloor-\\operatorname{max}(\\sqrt n,\\lfloor \\frac{r_l-l}{cnt} \\rfloor)⌊cntrr​−l+1​⌋−max(n​,⌊cntrl​−l​⌋)。记住取 max⁡\\operatorname{max}max 的原因是此时我们讨论的是 k&gt;nk &gt; \\sqrt nk&gt;n​ 的情况，k≤nk \\le \\sqrt nk≤n​ 的情况要舍掉。 Code 代码 string s,t;int n,blo,sum[N],pos[N],cnt[500*N];//桶的范围要开大一点ll ans;int main()&#123; cin&gt;&gt;t;s+=&quot; &quot;;s+=t;n=s.size()-1;//下标从 1 开始 blo=sqrt(n);//块长，我们以根号n分类讨论 for(rint k=1;k&lt;=blo;k++)&#123; cnt[n]=1; for(rint i=1;i&lt;=n;i++)&#123; sum[i]=sum[i-1]+(s[i]==&#x27;1&#x27;?k-1:-1);//赋值 ans+=cnt[sum[i]+n]; cnt[sum[i]+n]++; &#125; for(rint i=1;i&lt;=n;i++) cnt[sum[i]+n]--; for(rint i=1;i&lt;=n;i++) sum[i]=0; &#125; for(rint i=1;i&lt;=n;i++)&#123; if(s[i]==&#x27;1&#x27;) sum[i]=sum[i-1]+1,pos[sum[i]]=i; else sum[i]=sum[i-1]; &#125;//预处理前缀和 和 1 的下标 pos[sum[n]+1]=n+1;//设个右端点防止越界问题 for(rint l=1;l&lt;=n;l++)&#123;//枚举左端点 for(rint i=1;i&lt;=n/blo;i++)&#123;//枚举 1 的个数 int rl=pos[i+sum[l-1]],rr=pos[i+sum[l-1]+1]-1,res=(rr-l+1)/i-max(blo,(rl-l)/i); if(rl&gt;0&amp;&amp;rr&gt;0&amp;&amp;res&gt;0) ans+=res; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"根号分块","slug":"根号分块","permalink":"https://volantis.js.org/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E5%9D%97/"}],"author":"Mr.Az"},{"title":"题解：CF1860A Not a Substring","slug":"题解：CF1860A Not a Substring","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：CF1860A Not a Substring/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF1860A%20Not%20a%20Substring/","excerpt":"","text":"Question 问题 CF1860A Not a Substring Analysis 分析 可以观察到只有字符串为 () 时无解，其他都可以构造出反例。 考虑特殊反例 ()()...() 和 ((...()...)) ，只要字符串 sss 是其中一个反例的子串，那么其必然不是另一个反例的子串。暴力判断即可。 赛时我用的是整个串的匹配，不过赛后发现可以匹配 )() 或者 (()，跟匹配整个字符串是一个道理。","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://volantis.js.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Mr.Az"},{"title":"题解：CF1860C Game on Permutation","slug":"题解：CF1860C Game on Permutation","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：CF1860C Game on Permutation/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF1860C%20Game%20on%20Permutation/","excerpt":"","text":"Question 问题 CF1860C Game on Permutation 有一个有 nnn 个元素的全排列，Alice 先放一个筹码在第 iii 个元素上，在每次下一步中，当前玩家必须将筹码移动到同时向左且严格小于当前元素的任何元素。若当前玩家无法移动，则该玩家胜利。 称其中第 iii 个元素是幸运的仅当 Alice 把筹码放置在第 iii 个元素的时候，无论 Bob 怎么移动 Alice 都可以获胜。 Analysis 分析 研究样例可发现若一旦放置在第 iii 个元素的时候就无法动了，那么此时肯定是 Bob 获胜。那我们需要往后找到直到这个元素可以动。那么这就是第一个幸运元素。 后面的元素何时会是幸运的呢？观察到如果 Bob 可以从第 iii 个元素移动到前面任意一个幸运元素，则 Bob 获胜。所以我们要满足第 iii 个元素的大小要小于其前面所有幸运元素。 只需要记一个数组 mnimn_imni​ 代表第 iii 个元素前最小的幸运元素即可。 Code 代码 const int N=3e5+8;int T,n,p[N],mn[N];bool f[N];int main()&#123; read(T); while(T--)&#123; read(n);int Min=inf;mn[0]=inf;ll cnt=0; for(rint i=1;i&lt;=n;i++) f[i]=0; for(rint i=1;i&lt;=n;i++)&#123; read(p[i]); if(p[i]&lt;Min) f[i]=1,Min=p[i];//f[i] 代表第 i 个点 0:可以移动 1:不可移动 &#125; for(rint i=1;i&lt;=n;i++)&#123; if(!f[i])&#123; if(p[i]&lt;mn[i-1]) mn[i]=min(mn[i-1],p[i]),cnt++; else mn[i]=mn[i-1]; &#125; else mn[i]=mn[i-1]; &#125; printf(&quot;%lld\\n&quot;,cnt); &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://volantis.js.org/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"author":"Mr.Az"},{"title":"题解：CF1858B The Walkway","slug":"题解：CF1858B The Walkway","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：CF1858B The Walkway/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF1858B%20The%20Walkway/","excerpt":"","text":"Question 问题 CF1858B The Walkway 题目大意: 有 nnn 个板凳，小 P 想要从第 111 个板凳走到第 nnn 个。小 P 在第 iii 个板凳会吃饼干当且满足至少一个下列的要求: 第 iii 个长凳附近有一个饼干卖家。 当前处于第 111 个长凳。 前 ddd 分钟没有吃饼干。 若同时满足多个要求，只吃一个饼干。可以移除一个饼干商家。问小 P 最少可以吃多少个饼干以及有多少种合法移除。 Analysis 分析 考虑移除一个商家会带来的影响。可发现小 P 从第 111 个板凳走到第 i−1i-1i−1 个饼干店和第 i+1i+1i+1 个饼干店到最后第 nnn 个板凳所要吃的饼干是不变的。也就是说，唯一会改变的是第 i−1i-1i−1 个饼干店到第 i+1i+1i+1 个饼干店这一段要吃的饼干。 总饼干数量可抽象为以下三段的贡献： (1→si−1)+(si−1→si+1)+(si+1→n)\\left(1 \\to s_{i-1} \\right) + \\left(s_{i-1} \\to s_{i+1} \\right) + \\left(s_{i+1} \\to n \\right) (1→si−1​)+(si−1​→si+1​)+(si+1​→n) Solution 这边为了方便，我们在第 nnn 个板凳处建一个&quot;饼干店&quot;，但不参与吃饼干的计算。即 sm+1=ns_{m+1}=nsm+1​=n。 我们记: preipre_iprei​ 代表从第 111 个板凳走到第 iii 个饼干店要吃的饼干。即上面的 (1→si)\\left(1 \\to s_{i} \\right)(1→si​)。 lstilst_ilsti​ 代表从第 iii 个板凳走到第 nnn 个板凳要吃的饼干。(si→n)\\left(s_{i} \\to n \\right)(si​→n)。 那么移除第 iii 个饼干店后要吃的饼干就等于： prei−1+⌊si+1−si−1−[i≠m]d⌋+lsti+1pre_{i-1}+ \\lfloor \\frac{s_{i+1}-s_{i-1}-[i \\neq m]}{d} \\rfloor +lst_{i+1} prei−1​+⌊dsi+1​−si−1​−[i=m]​⌋+lsti+1​ 具体细节见代码。 Code 代码 int t,n,m,d;int s[N];ll lst[N],pre[N],ans=INF;int main()&#123; read(t); while(t--)&#123; read(n,m,d);ans=INF; for(rint i=1;i&lt;=m;i++) read(s[i]); pre[0]=1;s[0]=1;s[m+1]=n;lst[m+1]=0;//预处理 for(rint i=1;i&lt;=m;i++)&#123; if(s[i]==1) pre[i]=1; else pre[i]=pre[i-1]+(s[i]-s[i-1]-1)/d+1; &#125;//pre的预处理 for(rint i=m;i&gt;=1;i--) lst[i]=(s[i+1]-s[i]-(i!=m))/d+lst[i+1]+1;//lst的预处理 ll res=0,cnt=0; for(rint i=1;i&lt;=m;i++)&#123; res=pre[i-1]+(s[i+1]-s[i-1]-(i!=m))/d+lst[i+1]; if(res&lt;ans) ans=res,cnt=1; else if(res==ans) cnt++;//注意题目统计的是移除哪些饼干店可以打到吃最少饼干的要求 &#125; printf(&quot;%lld %lld\\n&quot;,ans,cnt); &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[],"author":"Mr.Az"},{"title":"题解：CF1986G2 Permutation Problem (Hard Version)","slug":"题解：CF1986G2 Permutation Problem (Hard Version)","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：CF1986G2 Permutation Problem (Hard Version)/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF1986G2%20Permutation%20Problem%20(Hard%20Version)/","excerpt":"","text":"Question 问题 CF1986G2 Permutation Problem (Hard Version) 给定一个 1∼n1\\sim n1∼n 的排列 ppp，求整数对 (i,j)(i,j)(i,j) 的数量，满足 1≤i&lt;j≤n1\\le i&lt;j\\le n1≤i&lt;j≤n 且 pi⋅pjp_i\\cdot p_jpi​⋅pj​ 能被 i⋅ji\\cdot ji⋅j 整除。每个测试点 ttt 组测试用例。 数据范围 1≤n≤5⋅1051\\le n\\le 5\\cdot 10^51≤n≤5⋅105； ∑n≤5⋅105\\sum n\\le 5\\cdot 10^5∑n≤5⋅105。 Analysis 思路分析 首先对于 pi⋅pji⋅j\\frac{p_i \\cdot p_j}{i \\cdot j}i⋅jpi​⋅pj​​ 是否为整数，我们会发现可能 i,ji,ji,j 可能存在 pip_ipi​ 的因数，这让我们解题变得更加复杂。我们想让影响的因素尽可能减少。 发现该形式可以写作 pii⋅pjj\\frac{p_i}{i} \\cdot \\frac{p_j}{j}ipi​​⋅jpj​​，所以我们可以先将 {pi,i}\\{p_i,i\\}{pi​,i} 分别除去他们两个的 gcd⁡\\gcdgcd。这一步是为了避免 pip_ipi​ 和 iii 之间存在可能可以除的关系。 也就是令 ai=igcd⁡(pi,i)a_i=\\frac{i}{\\gcd(p_i,i)}ai​=gcd(pi​,i)i​，bi=pigcd⁡(pi,i)b_i=\\frac{p_i}{\\gcd(p_i,i)}bi​=gcd(pi​,i)pi​​，该问题就转化为了求 ai∣bja_i \\mid b_jai​∣bj​ 并且 aj∣bia_j \\mid b_iaj​∣bi​ 的 {i,j}\\{i,j\\}{i,j} 有序二元组。思考如何计算。 Solution 数学 感觉整体的思路就是 bi→扩倍ai→查询{aj,bj}b_i \\stackrel{\\text{扩倍}}\\to a_i \\stackrel{\\text{查询}}\\to \\{a_j,b_j\\}bi​→扩倍ai​→查询{aj​,bj​} 如同通关游戏一样。我们可以先枚举 bib_ibi​ 在借此枚举出 bib_ibi​ 的倍数 aia_iai​，并在此基础上查询有多少个 bjb_jbj​ 符合 ai∣bja_i \\mid b_jai​∣bj​，那这样子的话就符合了我们的 ai∣bja_i \\mid b_jai​∣bj​ 并且 aj∣bia_j \\mid b_iaj​∣bi​ 的条件，关键在于如何查询。 最初的想法是维护一个二维数组 cnti,jcnt_{i,j}cnti,j​ 表示满足 ak=ia_k=iak​=i 并且 j∣bkj \\mid b_kj∣bk​。但是很容易发现我们连数组都开不下。即使考虑使用 map 维护，最坏的情况下空间会因为 map 被插入内容过大而爆炸，这也是很多人在此题 128MiB 的限制下 MLE 了。 考虑如何优化，我们会发现 cntx,...cnt_{x,...}cntx,...​ 只会在所有 x∣bjx \\mid b_jx∣bj​ 的 jjj 有贡献出现。那这样子我们只需要去枚举 jjj 即可，压掉一维。 或者换一种方式思考，我们当前先枚举 bib_ibi​ 后可以通过我们建立的 {ai}\\{a_i\\}{ai​} 和 {bi}\\{b_i\\}{bi​} 双射找到其对应的所有 {ai}\\{a_i\\}{ai​}。那这样下来，我们未知的就只剩下 {aj,bj}\\{a_j,b_j\\}{aj​,bj​} 了。所以我们再度枚举 aja_jaj​ 并保证他是 bib_ibi​ 的倍数，去找对应满足 bj∣aib_j \\mid a_ibj​∣ai​ 的 bjb_jbj​ 数量了。 我们预处理出该 bib_ibi​ 对应的所有 {ai}\\{a_i\\}{ai​} 的因数个数和。令 cnticnt_icnti​ 表示有多少个 aia_iai​ 拥有 iii 这个因数。接下来枚举 aia_iai​ 的倍数，并计算出此时 k⋅bi=ajk\\cdot b_i=a_jk⋅bi​=aj​ 对应的所有 {bi}\\{b_i\\}{bi​}，那么 aja_jaj​ 对答案的贡献就是 cntbicnt_{b_i}cntbi​​。 在最后，由于本题询问的是有序二元组，以上做法并没有考虑 i&lt;ji &lt; ji&lt;j，所以最终答案需要除以二。同时当 i=ji=ji=j，只会在 ai∣bia_i \\mid b_iai​∣bi​ 时产生一个贡献。所以提前减掉即可。 记得清空。 时间复杂度： 因为 [1,n][1,n][1,n] 之间的因数个数和的复杂度为 O(nln⁡n)O(n\\ln n)O(nlnn)，下面统计答案首先枚举 bib_ibi​，并且还去寻找其对应的所有因数，整体的复杂度与上面同阶为 O(∑facai)≤O(nln⁡n)O(\\sum fac_{a_i}) \\le O(n \\ln n)O(∑facai​​)≤O(nlnn)，所以整体复杂度为 O(nln⁡n)O(n \\ln n)O(nlnn)。 Code 代码 signed main()&#123; for(rint i=1;i&lt;=N-7;i++) for(rint j=i;j&lt;=N-7;j+=i) fac[j].pb(i); read(T); while(T--)&#123; ans=0; read(n); for(rint i=1,t;i&lt;=n;i++)&#123; read(t); int x=i/__gcd(i,t),y=t/__gcd(i,t);//除去 gcd a[x].pb(y);b[y].pb(x);//建立双射，有利于计算答案 if(x==1) ans--;//对于 i=j 且 ai|bi 的情况提前减掉 &#125; for(rint i=1;i&lt;=n;i++)&#123; for(auto a1:a[i]) for(auto a2:fac[a1]) cnt[a2]++;//处理因数个数和 for(rint a2=i;a2&lt;=n;a2+=i) for(auto b1:b[a2]) ans+=cnt[b1];//计算贡献 for(auto a1:a[i]) for(auto a2:fac[a1]) cnt[a2]=0;//清空 &#125; for(rint i=1;i&lt;=n;i++) a[i].clear(),b[i].clear();//清空 cout&lt;&lt;ans/2&lt;&lt;endl;//注意有序，除以二 &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://volantis.js.org/tags/%E6%95%B0%E8%AE%BA/"}],"author":"Mr.Az"},{"title":"题解：Frequent values","slug":"题解：Frequent values","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：Frequent values/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AFrequent%20values/","excerpt":"","text":"Frequent values 双倍经验： UVA11235 SP1684 求区间众数的出现次数。 Analysis 分析 莫队。 Solution 莫队 考虑扩展和删除一个数。 add:add:add: 扩展一格是简单的，只需要记一个数组 cntxcnt_xcntx​ 代表 xxx 出现的次数，用来更新当前答案 resresres 即可。 del:del:del: 删除一格我们发现只记一个数组 cntxcnt_xcntx​ 是不够的。我们再引入 totxtot_xtotx​ 代表出现了 xxx 次的数有几个。 这时 cntx=rescnt_x=rescntx​=res 和 totcntx=0tot_{cnt_x}=0totcntx​​=0 ，如果两个条件都满足，就表示众数的个数少了一个，即 res−−res--res−−。 观察到 aia_iai​ 值域包含负数，可以把所有的 aia_iai​ 都加上 1e5。 同时注意莫队移动的顺序。 Code 代码 int n,T,blo,res=-1;int a[N],ans[N];int cnt[N*2],tot[N*2];//cnt[x]: x出现的次数 tot[x]: 出现次数为x的数的个数inline int num(int x)&#123;return x/blo;&#125;struct ask&#123; int l,r,id; bool operator&lt;(const ask &amp;A)const&#123; if(num(l)!=num(A.l)) return num(l)&lt;num(A.l); return (num(A.l)&amp;1)?r&lt;A.r:r&gt;A.r; &#125;&#125;q[N];inline void add(int x)&#123; x=a[x]; tot[cnt[x]]--;cnt[x]++;tot[cnt[x]]++; res=max(res,cnt[x]); return ;&#125;inline void del(int x)&#123; x=a[x]; tot[cnt[x]]--; if(cnt[x]==res&amp;&amp;tot[cnt[x]]==0) res--; cnt[x]--;tot[cnt[x]]++; return ;&#125;int main()&#123; while(1)&#123; res=-1; read(n); if(!n) return 0;//多测退出 read(T); mem(tot,0);mem(cnt,0);//多测清空 blo=sqrt(n); for(rint i=1;i&lt;=n;i++) read(a[i]),a[i]+=N; for(rint i=1;i&lt;=T;i++)&#123; int x,y;read(x,y); q[i]=&#123;x,y,i&#125;; &#125; sort(q+1,q+T+1); int l=1,r=0; for(rint i=1;i&lt;=T;i++)&#123; //注意转移顺序，会T while(l&lt;q[i].l) del(l++); while(l&gt;q[i].l) add(--l); while(r&gt;q[i].r) del(r--); while(r&lt;q[i].r) add(++r); ans[q[i].id]=res; &#125; for(rint i=1;i&lt;=T;i++) printf(&quot;%lld\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"https://volantis.js.org/tags/%E8%8E%AB%E9%98%9F/"}],"author":"Mr.Az"},{"title":"题解：NOIp和省选 题解","slug":"题解：NOIp和省选 题解","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：NOIp和省选 题解/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ANOIp%E5%92%8C%E7%9C%81%E9%80%89%20%E9%A2%98%E8%A7%A3/","excerpt":"","text":"官方题解请移步此处 大致题意 有两道题目，满分分别为 400分 和 600分 。每一个人的分数在0至满分 有 nnn 名同学，其中第 iii 名同学得分分别为 aia_iai​ 和 bib_ibi​，通过以下规则计算第 iii 名同学的标准得分 cic_ici​： 分别统计两场比赛的最高分 A,BA,BA,B，有 A≠0A\\ne 0A=0，B≠0B\\ne 0B=0。 令 ci=1000(aiA+biB)c_i=1000(\\frac{a_i}{A}+\\frac{b_i}{B})ci​=1000(Aai​​+Bbi​​)，其中 cic_ici​ 四舍五入保留到整数。 简单来说，已知 nnn 和每位同学的 c1∼nc_{1\\sim n}c1∼n​，其中第一个人c1=2000c_1=2000c1​=2000 即两场均为最高分（A，B），构造一组合法解 a1∼na_{1\\sim n}a1∼n​，b1∼nb_{1\\sim n}b1∼n​ 满足上述要求。 分析（心理：考场上想了半天，其实就是打表） 1.数学 我令A=400，B=600，然后枚举每一个人的第一个分数ai(0∼400a_i(0\\sim 400ai​(0∼400)，然后通过解方程计算对应的bib_ibi​，看看构造是否合法。 2.打表 也许是码力问题，上述做法WA了，改为暴力枚举aia_iai​ 和 bib_ibi​，然后判断构造是否合法。直接输出会TLE。考虑数据范围较小，选择打表。提前用以上暴力方法枚举0∼19900\\sim19900∼1990，将答案记录下来。 代码 打表暴力枚举应该很简单吧，按照题目要求就行了。这里不给出代码了。","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://volantis.js.org/tags/%E6%95%B0%E8%AE%BA/"},{"name":"打表","slug":"打表","permalink":"https://volantis.js.org/tags/%E6%89%93%E8%A1%A8/"}],"author":"Mr.Az"},{"title":"题解：P10161 [DTCPC 2024] 小方的疑惑 10","slug":"题解：P10161 [DTCPC 2024] 小方的疑惑 10","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P10161 [DTCPC 2024] 小方的疑惑 10/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP10161%20[DTCPC%202024]%20%E5%B0%8F%E6%96%B9%E7%9A%84%E7%96%91%E6%83%91%2010/","excerpt":"","text":"Question 问题 P10161 [DTCPC 2024] 小方的疑惑 10 要求构造一个长度为 nnn 的括号字符串，其中 kkk 个子串为合法的括号序列。无法构造输出 −1-1−1。 Analysis 分析 手玩一下可以发现最优情况有以下两种情况： ()()...() 如果有 xxx 对括号，则有 x(x+1)2\\frac{x(x+1)}{2}2x(x+1)​ 个字串为合法的括号序列。 (()()...()) 相当于在 111 情况外边加一层，多出一个合法字串，并且让当前括号对数变为 111 对。 以下令 s(x)=x(x+1)2s(x)=\\frac{x(x+1)}{2}s(x)=2x(x+1)​。 Solution 构造 我们可以通过这样构造类似 ((()()())()())()()()\\texttt{\\color{red}{(\\color{blue}(\\color{black}()()()\\color{blue})()()\\color{red})()()()}}((()()())()())()()() 这样的括号序列，用颜色标记出来了。计算的话分三层分别是最里面的 333 对，中间的 2+12+12+1 对，最外层 3+13+13+1 对（+1+1+1 的原因是第 222 种情况会使括号对变为 111，要加上）。最终总共的合法字串数为：s(3)+s(3)+s(4)=22s(3)+s(3)+s(4)=22s(3)+s(3)+s(4)=22 对。 也就是说，我们相当于把这个构造的字符串分为 mmm 层，每层填 aia_iai​ 对括号，则总的合法括号字串数为 ∑i=1ms(ai)\\displaystyle \\sum_{i=1}^{m} s(a_i)i=1∑m​s(ai​)。 其实这个问题相当于完全背包。 背包容量为 kkk，每个货物（也就是每一层填入的括号组数）的体积是 s(x)s(x)s(x)，价值是 xxx，每一件可以无限选。问填满背包的最小价值。 跑一遍完全背包，记录一下转移的路径，输出即可。无解即为最小值比 nnn 大。 Specific 细节 如果有剩余的部分全部输出 '('。 除第一层外的每一层都有多一对括号对，输出时要注意 输出答案我使用了一个抽象方法，详见代码。 贪心找最大的 s(x)s(x)s(x) 去填可以被卡，数据如下（但好像很少可以被卡掉）。 input 28 54 output ((()()()()()()()()())()())() Code 代码 int T,n,m; int v[N],w[N],f[N],turn[N];signed main()&#123; read(T); for(rint i=1;i&lt;=N-8;i++) w[i]=-(2*i),v[i]=(i+1)*i/2;&lt;!-- 预处理货物的体积和价值 --&gt; for(rint i=1;i&lt;=N-8;i++) f[i]=-inf; for(rint i=1;i&lt;=N-8;i++)&#123; for(rint j=v[i];j&lt;=N-8;j++)&#123; if(f[j]&lt;f[j-v[i]]+w[i]) turn[j]=i, f[j]=f[j-v[i]]+w[i]; &lt;!-- 记录转移路径 --&gt; &#125; &#125;&lt;!-- 完全背包 --&gt; while(T--)&#123; read(n,m); if(-f[m]&gt;n) puts(&quot;-1&quot;); else&#123; &lt;!-- 细节3：神奇输出方式 --&gt; &lt;!-- 构造一个长度为两倍的字符串，记录左端点 l 和右端点 r，两个都在中间 --&gt; &lt;!-- 这样就可以一边填括号，一边在外边套一层括号 --&gt; &lt;!-- 最后输出 [l,r] 里的字符串 --&gt; char s[200008]=&quot;&quot;;int l=100000,r=100000,now=m; for(rint i=turn[now];i;i=turn[now])&#123; &lt;!-- 沿着记录的路径倒推 --&gt; for(rint j=1;j&lt;=i-(now!=m);j++) s[r]=&#x27;(&#x27;,s[r+1]=&#x27;)&#x27;,r+=2;&lt;!-- 往右填括号对 例：()() --&gt; l--;s[l]=&#x27;(&#x27;;s[r]=&#x27;)&#x27;;r++;&lt;!-- 外面包一层 例：(()()) --&gt; now=now-v[turn[now]];&lt;!-- 沿着记录的路径倒推 --&gt; &#125; l++;r-=2;&lt;!-- 会多包一层，删掉 --&gt; for(rint i=l;i&lt;=r;i++) putchar(s[i]); for(rint i=r-l+1;i&lt;n;i++) putchar(&#x27;(&#x27;);puts(&quot;&quot;);&lt;!-- 细节1：补充剩余的左括号 例：(()())(((( --&gt; &#125; &#125; return 0;&#125; Proof 补充证明 为何如上的构造是消耗最小括号的构造方案？其实任意一种括号序列都可以转化为其上的方案。任意一种括号序列可以看作合法括号序列 aia_iai​ 和非法括号序列 bib_ibi​ 相交织（aia_iai​ 和 bib_ibi​ 可以是 000），也就是如下形式： b1a1b2a2...am−1bmb_1a_1b_2a_2...a_{m-1}b_m b1​a1​b2​a2​...am−1​bm​ Step 1 扔掉最两边的 b1b_1b1​ 和 bmb_mbm​，不影响结果。转化后为：a1b2a2...am−1a_1b_2a_2...a_{m-1}a1​b2​a2​...am−1​ Step 2 我们发现每两个合法括号序列之间必有一非法括号序列相隔，我们可以把 a1a_1a1​ 塞入 a2a_2a2​ 的第一个括号里，然后把 b2b_2b2​ 扔掉，合法字串数显然不变而消耗的括号减少了 b2b_2b2​ 个。以此类推，把 a2a_2a2​ 塞入 a3a_3a3​，扔掉 b3b_3b3​ 一直到 am−2a_{m-2}am−2​ 塞入 am−1a_{m-1}am−1​ 扔掉 bm−1b_{m-1}bm−1​。最后出来的即为我们以上构造的方案。而长度较原先减少了 ∑i=1mbi\\sum_{i=1}^m b_i∑i=1m​bi​ 个括号，故为最短的构造方案。 模拟一下 原括号序列 )))(()()()(((()())(()()(((\\texttt{)))(()()()(((()())(()()(((})))(()()()(((()())(()()((( Step 1： \\texttt{)))( \\color{ #00BA00}()()() \\color{black}(( \\color{blue}(()())() \\color{black}( \\color{red}()() \\color{black}(((} \\texttt{\\color{ #00BA00}()()() \\color{black}(( \\color{blue}(()())() \\color{black}( \\color{red}()()} Step 2： \\texttt{\\color{blue}((\\color{ #00BA00}()()()\\color{blue})())() \\color{black}( \\color{red}()()} \\texttt{\\color{red}(\\color{blue}((\\color{ #00BA00}()()()\\color{blue})())()\\color{red})()} 题外话 直接用 string 输出好像也没事？","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://volantis.js.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"},{"name":"完全背包","slug":"完全背包","permalink":"https://volantis.js.org/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"}],"author":"Mr.Az"},{"title":"题解：P10236 [yLCPC2024] D. 排卡","slug":"题解：P10236 [yLCPC2024] D. 排卡","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P10236 [yLCPC2024] D. 排卡/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP10236%20[yLCPC2024]%20D.%20%E6%8E%92%E5%8D%A1/","excerpt":"","text":"Question 问题 P10236 [yLCPC2024] D. 排卡 题目大意：给定长度为 n(2≤n≤1000)n(2 \\le n \\le 1000)n(2≤n≤1000) 的序列 aaa，每次可以从头或尾选一个数放到序列 bbb（选后删除），求∑i=1n−1bibi+1\\displaystyle \\sum_{i=1}^{n-1} b_i^{b_{i+1}}i=1∑n−1​bibi+1​​ 的最大值。（我们仅在计算 bibi+1b_i^{b_{i+1}}bibi+1​​ 的时候将得分对 998244353998244353998244353 取模）。 Analysis 分析 首先思考贪心：（错解） 第一个从最左边或最右边拿，然后贪心第二个从最左边还是最右边使得 b1b2b_1^{b_2}b1b2​​ 最大，一直这样贪心下去。很明显是错的。但很明显连样例的过不了，正确性显然不存在。 观察到 nnn 的范围较小，发现想复杂了，直接暴力区间 DPDPDP 即可。 Solution 定义 fl,r,(0,1)f_{l,r,(0,1)}fl,r,(0,1)​ 为区间 [l,r][l,r][l,r] 最后弹掉的是最左边的（0）还是最右边的（1）。 转移方程非常好写： fl,r,0=max⁡{fl+1,r,0+alal+1,fl+1,r,1+alar}fl,r,1=max⁡{fl,r−1,0+aral,fl,r−1,1+arar−1}\\begin{aligned} f_{l,r,0}&amp;=\\max{\\{f_{l+1,r,0}+a_l^{a_{l+1}},f_{l+1,r,1}+a_l^{a_{r}}\\}}\\\\ f_{l,r,1}&amp;=\\max{\\{f_{l,r-1,0}+a_r^{a_{l}},f_{l,r-1,1}+a_r^{a_{r-1}}\\}} \\end{aligned} fl,r,0​fl,r,1​​=max{fl+1,r,0​+alal+1​​,fl+1,r,1​+alar​​}=max{fl,r−1,0​+aral​​,fl,r−1,1​+arar−1​​}​ 对于 fl,r,0f_{l,r,0}fl,r,0​ 的转移进行一个详细的讲述，fl,r,1f_{l,r,1}fl,r,1​ 同理。 它只能从 [l+1,r][l+1,r][l+1,r] 转移而来，因为他最后踢掉的是最左边的。所以要么是 fl+1,r,0+alal+1f_{l+1,r,0}+a_l^{a_{l+1}}fl+1,r,0​+alal+1​​ 要么就是 fl+1,r,1+alarf_{l+1,r,1}+a_l^{a_{r}}fl+1,r,1​+alar​​. Code 代码 signed main()&#123; read(T); while(T--)&#123; read(n); for(rint i=1;i&lt;=n;i++) read(a[i]); for(rint i=1;i&lt;=n;i++) for(rint j=1;j&lt;=n;j++) f[i,j,0]=f[i,j,1]=0; for(rint len=2;len&lt;=n;len++)&#123; for(rint l=1;l&lt;=(n-len+1);l++)&#123; int r=l+len-1; f_&#123;l,r,0&#125;=max(&#123;f_&#123;l,r,0&#125;,f[l+1,r,0]+power(a[l],a[l+1]),f[l+1,r,1]+power(a[l],a[r])&#125;); f_&#123;l,r,1&#125;=max(&#123;f_&#123;l,r,1&#125;,f[l,r-1,0]+power(a[r],a[l]),f[l,r-1,1]+power(a[r],a[r-1])&#125;); &#125; &#125; printf(&quot;%lld\\n&quot;,max(f[1,n,0],f[1,n,1])); &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"区间 DP","slug":"区间-dp","permalink":"https://volantis.js.org/tags/%E5%8C%BA%E9%97%B4-dp/"}],"author":"Mr.Az"},{"title":"题解：P10368「LAOI-4」Colors","slug":"题解：P10368「LAOI-4」Colors","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P10368「LAOI-4」Colors/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP10368%E3%80%8CLAOI-4%E3%80%8DColors/","excerpt":"","text":"T1「LAOI-4」Colors Solution：暴力模拟 可以证明消除次数不会很多（大概最多是2次？），所以直接暴力模拟。 简要证明： 会消除的序列在原序列中呈 aba 型排列，消除后所有的 b 被消除，剩下的只有 aaa 型排列，再次消除就不存在 aba 的结构了。 细节 记得特判 n≤2n \\leq 2n≤2 和 k=0k=0k=0 的情况，此时直接输出，无需操作。 若这次遍历无需修改，则直接退出。 Code: signed main()&#123; read(T,id); while(T--)&#123; read(n,k); cin&gt;&gt;s; if(n&lt;=2||k==0)&#123;cout&lt;&lt;s&lt;&lt;&quot;\\n&quot;;continue;&#125; //细节1 for(rint i=1;i&lt;=k;i++)&#123; t=&quot;&quot;;t+=s[0];bool f=1; for(rint j=1;j&lt;s.size()-1;j++)&#123; if(s[j-1]!=s[j+1]) t+=s[j]; else f=0; &#125; t+=s[s.size()-1]; if(f) break;//细节2 s=t; &#125; cout&lt;&lt;t&lt;&lt;endl; &#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://volantis.js.org/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Az"},{"title":"题解：P10369 「LAOI-4」Mex Tower (Easy ver.)","slug":"题解：P10369 「LAOI-4」Mex Tower (Easy ver.)","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P10369 「LAOI-4」Mex Tower (Easy ver.)/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP10369%20%E3%80%8CLAOI-4%E3%80%8DMex%20Tower%20(Easy%20ver.)/","excerpt":"","text":"T2「LAOI-4」Mex Tower (Easy ver.) 根据 T3 性质反推即可。 T3 性质： 对于 nnn 为奇数时： 中间项必为 2。 中间项左右两侧必为 [1,0][1,0][1,0] 或 [2,0][2,0][2,0] 或 [0,1][0,1][0,1] 或 [0,2][0,2][0,2]。 对于 nnn 为偶数时，中间两项为 [0,1][0,1][0,1] 或 [1,0][1,0][1,0]。 Code: 本人赛时模拟 n=7n=7n=7 样例后构造的： signed main()&#123; read(T); while(T--)&#123; read(n); if(n&amp;1)&#123; for(rint i=1;i&lt;=(n-1)/2;i++) putchar(&#x27;1&#x27;),putchar(&#x27; &#x27;); putchar(&#x27;2&#x27;),putchar(&#x27; &#x27;); for(rint i=1;i&lt;=(n-1)/2;i++) putchar(&#x27;0&#x27;),putchar(&#x27; &#x27;); &#125; else&#123; for(rint i=1;i&lt;=n/2;i++) putchar(&#x27;0&#x27;),putchar(&#x27; &#x27;); for(rint i=1;i&lt;=n/2;i++) putchar(&#x27;1&#x27;),putchar(&#x27; &#x27;); &#125; puts(&quot;&quot;); &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"}],"author":"Mr.Az"},{"title":"题解：P10370 「LAOI-4」Mex Tower (Hard ver.)","slug":"题解：P10370 「LAOI-4」Mex Tower (Hard ver.)","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P10370 「LAOI-4」Mex Tower (Hard ver.)/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP10370%20%E3%80%8CLAOI-4%E3%80%8DMex%20Tower%20(Hard%20ver.)/","excerpt":"","text":"T3「LAOI-4」Mex Tower (Hard ver.) Solution：猜性质 打表观察（真的是）得： 对于 nnn 为奇数时： 中间项必为 2。 中间项左右两侧必为 [1,0][1,0][1,0] 或 [2,0][2,0][2,0] 或 [0,1][0,1][0,1] 或 [0,2][0,2][0,2]。 对于 nnn 为偶数时，中间两项为 [0,1][0,1][0,1] 或 [1,0][1,0][1,0]。 细节 原始数组先处理一遍成只有 0,1,20,1,20,1,2 的数组。 nnn 为奇数时，特判 n=1n=1n=1 时情况，此时只需要 a1=2a_1=2a1​=2 即可。 证明： 其实在手模的时候就可以看出不超过 4 次操作后，继续操作两次相当于减去一对头尾，最后剩下的只有中间。所以中间只要构造为 [0,2,1][0,2,1][0,2,1] 或者 [0,1][0,1][0,1] 这样的样子。 Code: signed main()&#123; read(T); while(T--)&#123; read(n); for(rint i=1;i&lt;=n;i++) read(a[i]); n--; for(rint i=1;i&lt;=n;i++)&#123; if(a[i]!=0&amp;&amp;a[i+1]!=0) a[i]=0; else if(a[i]!=1&amp;&amp;a[i+1]!=1) a[i]=1; else a[i]=2; &#125;//细节1 bool f=0; if(n%2==1)&#123; int t=(n+1)/2; if(t==1&amp;&amp;a[t]==2) f=1;//细节2 else if(a[t]==2&amp;&amp;a[t-1]!=a[t+1]&amp;&amp;(a[t-1]==0||a[t+1]==0)) f=1; &#125; else&#123; if(a[n/2]+a[n/2+1]==1) f=1; &#125; puts(f?&quot;Yes&quot;:&quot;No&quot;); &#125; return 0;&#125; 打表代码： int n;inline int work(vector&lt;int&gt; a)&#123; for(rint k=1;k&lt;a.size();k++)&#123; for(rint i=1;i&lt;a.size();i++)&#123; if(a[i-1]!=0&amp;&amp;a[i]!=0) a[i-1]=0; else if(a[i-1]!=1&amp;&amp;a[i]!=1) a[i-1]=1; else a[i-1]=2; &#125; &#125; return a[0];&#125;inline void dfs(int p,vector&lt;int&gt; a)&#123; if(p&gt;n)&#123; if(work(a)==2)&#123;for(auto x:a) cout&lt;&lt;x&lt;&lt;&quot; &quot;;puts(&quot;&quot;);&#125; return ; &#125; a.push_back(0); dfs(p+1,a); a.pop_back();a.push_back(1); dfs(p+1,a); a.pop_back();a.push_back(2); dfs(p+1,a); return ; &#125; signed main()&#123; cin&gt;&gt;n; dfs(1,&#123;&#125;); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"}],"author":"Mr.Az"},{"title":"题解：P2398 GCD SUM","slug":"题解：P2398 GCD SUM","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P2398 GCD SUM/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP2398%20GCD%20SUM/","excerpt":"","text":"Question 问题 P2398 GCD SUM ∑i=1n∑j=1ngcd⁡(i,j)\\sum_{i=1}^n \\sum_{j=1}^n \\gcd(i, j) i=1∑n​j=1∑n​gcd(i,j) Analysis 分析 1 前置芝士 ∑d∣nφ(d)=n\\sum_{d|n}\\varphi(d)=n d∣n∑​φ(d)=n 套路化GCD变形 ( 加上前置芝士 ) ∑i=1n∑j=1n∑d∣gcd(i,j)gcd⁡(i,j)\\sum_{i=1}^n \\sum_{j=1}^n\\sum_{d|gcd(i,j)} \\gcd(i, j) i=1∑n​j=1∑n​d∣gcd(i,j)∑​gcd(i,j) ∑i=1n∑j=1n∑d∣i,d∣jgcd⁡(i,j)\\sum_{i=1}^n \\sum_{j=1}^n\\sum_{d|i,d|j} \\gcd(i, j) i=1∑n​j=1∑n​d∣i,d∣j∑​gcd(i,j) ∑i=1n∑j=1n∑d=1nφ(d)[d∣i][d∣j]\\sum_{i=1}^n \\sum_{j=1}^n\\sum_{d=1}^n \\varphi(d)[d|i][d|j] i=1∑n​j=1∑n​d=1∑n​φ(d)[d∣i][d∣j] ∑d=1n\\sum_{d=1}^n∑d=1n​移到前面，改变顺序 ∑d=1nφ(d)∑i=1n∑j=1n[d∣i][d∣j]\\sum_{d=1}^n \\varphi(d)\\sum_{i=1}^n \\sum_{j=1}^n[d|i][d|j] d=1∑n​φ(d)i=1∑n​j=1∑n​[d∣i][d∣j] ∑d=1nφ(d)⌊nd⌋\\sum_{d=1}^n\\varphi(d)\\lfloor\\frac n d\\rfloor d=1∑n​φ(d)⌊dn​⌋ Analysis 分析 2 这是本人使用的炒鸡煎蛋版本 原题式子可转化为 ∑d=1nd×f[k]\\sum_{d=1}^n d\\times f[k] d=1∑n​d×f[k] f[k]f[k]f[k] 表示 gcd⁡(i,j)==k\\gcd(i,j)==kgcd(i,j)==k 的情况个数 s[k]s[k]s[k] 表示 k∣gcd⁡(i,j)k|\\gcd(i,j)k∣gcd(i,j) 的情况个数 ∴s[k]=f[k]+f[2k]+...+f[pk]=⌊nk⌋2\\therefore s[k]=f[k]+f[2k]+...+f[pk]= \\lfloor \\frac n k \\rfloor^2 ∴s[k]=f[k]+f[2k]+...+f[pk]=⌊kn​⌋2 ∴f[k]=⌊nk⌋2−(f[2k]+...+f[pk])\\therefore f[k]=\\lfloor \\frac n k \\rfloor^2-(f[2k]+...+f[pk]) ∴f[k]=⌊kn​⌋2−(f[2k]+...+f[pk]) 复杂度分析 =O(n×(1+12+13+...+1n)=O(n\\times(1+\\frac 1 2+\\frac 1 3+...+\\frac 1 n)=O(n×(1+21​+31​+...+n1​) =O(nH(n))=O(nH(n))=O(nH(n)) H(n)H(n)H(n) 为调和级数，由于本体数据范围不大因此可以通过 Code 代码 这里只给出第二种解法的代码 #include&lt;iostream&gt;using namespace std;long long n,ans,f[2000008];int main()&#123; cin&gt;&gt;n; for(int i=n;i;i--)&#123; f[i]=n/i*(n/i); for(int j=i&lt;&lt;1;j&lt;=n;j+=i) f[i]-=f[j]; ans+=f[i]*i; &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://volantis.js.org/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}],"author":"Mr.Az"},{"title":"题解：P2568 GCD","slug":"题解：P2568 GCD","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P2568 GCD/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP2568%20GCD/","excerpt":"","text":"asd## Question 问题 P2568 GCD ∑p∈prime∑i=1n∑j=1n[gcd⁡(i,j)==p]\\sum_{p\\in prime}\\sum_{i=1}^n \\sum_{j=1}^n [\\gcd(i, j)==p] p∈prime∑​i=1∑n​j=1∑n​[gcd(i,j)==p] Analysis 分析 1 （所以肯定有第二种思考的方法，看后面（目前没写）） 变形 ∑p∈prime∑i=1⌊np⌋∑j=1⌊np⌋[gcd⁡(i,j)==1]\\sum_{p\\in prime}\\sum_{i=1}^{\\lfloor{\\frac n p}\\rfloor} \\sum_{j=1}^{\\lfloor{\\frac n p}\\rfloor} [\\gcd(i, j)==1] p∈prime∑​i=1∑⌊pn​⌋​j=1∑⌊pn​⌋​[gcd(i,j)==1] 改变枚举上界 ∑p∈prime(∑i=1⌊np⌋(2∑j=1i[gcd(i,j)==1])−1)\\sum_{p\\in prime}(\\sum_{i=1}^{\\lfloor{\\frac n p}\\rfloor}(2\\sum_{j=1}^i[gcd(i,j)==1])-1) p∈prime∑​(i=1∑⌊pn​⌋​(2j=1∑i​[gcd(i,j)==1])−1) 容易发现后面的 ∑j=1i[gcd(i,j)==1]\\sum_{j=1}^i[gcd(i,j)==1]∑j=1i​[gcd(i,j)==1] 就是 φ(i)\\varphi(i)φ(i) 替换一下 ∑p∈prime(2∑i=1⌊np⌋φ(i)−1)\\sum_{p\\in prime}(2\\sum_{i=1}^{\\lfloor{\\frac n p}\\rfloor}\\varphi(i)-1) p∈prime∑​(2i=1∑⌊pn​⌋​φ(i)−1) 至此，该式子变换已经结束 我们只需要通过线性筛出 φ(i)\\varphi(i)φ(i) 和 primeprimeprime 做一个前缀和后 枚举所有p∈primep\\in primep∈prime 并且 p≤np\\le np≤n的所有情况就结束了 Code 代码 线性筛部分 void init()&#123; phi[1]=1; for(int i=2;i&lt;=n;i++)&#123; if(!f[i]) phi[i]=i-1,prime[++cnt]=i; for(int j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;=n;j++)&#123; f[prime[j]*i]=1; if(i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125; else phi[i*prime[j]]=phi[i]*phi[prime[j]]; &#125; &#125;&#125; 主函数 int main()&#123; cin&gt;&gt;n;init(); for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+phi[i]; for(int i=1;i&lt;=cnt;i++) ans+=2*sum[n/prime[i]]-1; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://volantis.js.org/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}],"author":"Mr.Az"},{"title":"题解：P8445 射命丸文的取材之旅","slug":"题解：P8445 射命丸文的取材之旅","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P8445 射命丸文的取材之旅/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP8445%20%E5%B0%84%E5%91%BD%E4%B8%B8%E6%96%87%E7%9A%84%E5%8F%96%E6%9D%90%E4%B9%8B%E6%97%85/","excerpt":"","text":"Question 问题 P8445 射命丸文的取材之旅 给定序列 {an},{bn}\\{a_n\\},\\{b_n\\}{an​},{bn​}，求一个序列 {cn}\\{c_n\\}{cn​} 满足 ∀i∈[1,n],ci∈{ai,bi}\\forall i\\in[1,n],c_i\\in\\{a_i,b_i\\}∀i∈[1,n],ci​∈{ai​,bi​}，最大化 max⁡{r−l+1−mex⁡{cl,cl+1,…,cr−1,cr}}(1≤l≤r≤n)\\max\\{r-l+1-\\operatorname{mex}\\{c_l,c_{l+1},\\dots, c_{r-1},c_r\\}\\}(1\\le l\\le r\\le n) max{r−l+1−mex{cl​,cl+1​,…,cr−1​,cr​}}(1≤l≤r≤n) 并输出该式子可能的最大值。 Analysis 分析 这道题的提示有两个地方： 数据范围，40% 的数据中 ai=bia_i = b_iai​=bi​ 直接把问题转换为给一个序列 {cn}\\{c_n\\}{cn​} 求那个式子的最大值。 另一个是 mex 我们发现这玩意比较难处理，但是数据范围较小。 Solution 所以我们考虑枚举 mex 的值。设当前枚举的 mex 为 ttt。 考虑在 40% 的数据下，什么时候一个区间的 mex 不可为 ttt ，即区间内出现了 ttt 这个数。所以我们在当前枚举的情况下，将每一个 ci=tc_i = tci​=t 是为一个墙，（特别地，cn+1=tc_{n+1}=tcn+1​=t ）任何合法的区间只能在墙内。所以我们记两个数组 lenilen_ileni​：mex 为 iii 时的最大答案，preipre_iprei​：iii 上一次出现的地方，那么就有 leni=max(lenai,i−preai−1)len_i=max(len_{a_i},i-pre_{a_i}-1)leni​=max(lenai​​,i−preai​​−1)。 考虑满分做法，我们会发现若 ai≠bia_i \\neq b_iai​=bi​ 是没有用的，因为若该区间 mex 为 aia_iai​，我们可以让这一位为 bib_ibi​，同理若 mex 为 bib_ibi​，这一位为 aia_iai​，对答案的计算毫无影响。所以我们只需要考虑 ai=bia_i = b_iai​=bi​ 的位置，按 40% 的处理方法进行计算。 实现注意： 我们可以将最后一位视作一堵墙，记得把这个答案也更新在其中 Code 代码 int n,ans;int a[N],b[N],pre[N],len[N];int main()&#123; read(n); for(rint i=1;i&lt;=n;i++) read(a[i]); for(rint i=1;i&lt;=n;i++) read(b[i]); for(rint i=1;i&lt;=n;i++)&#123; if(a[i]==b[i])&#123; len[a[i]]=max(len[a[i]],i-pre[a[i]]-1); pre[a[i]]=i; &#125; &#125; for(rint i=0;i&lt;=n;i++) len[i]=max(len[i],n-pre[i]);//实现注意 1 for(rint i=0;i&lt;=n;i++) ans=max(ans,len[i]-i); printf(&quot;%d\\n&quot;,ans); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[],"author":"Mr.Az"},{"title":"题解：P8986 [北大集训 2021] 基因编辑","slug":"题解：P8986 [北大集训 2021] 基因编辑","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P8986 [北大集训 2021] 基因编辑/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP8986%20[%E5%8C%97%E5%A4%A7%E9%9B%86%E8%AE%AD%202021]%20%E5%9F%BA%E5%9B%A0%E7%BC%96%E8%BE%91/","excerpt":"","text":"Question 问题 P8986 [北大集训 2021] 基因编辑 给定一个长度为 nnn 的序列 aaa 以及需要切割的范围 l,rl,rl,r，求其中最短的合法子序列 (x,y)(x,y)(x,y) 满足： x&lt;l,y&gt;rx&lt;l,y&gt;rx&lt;l,y&gt;r 不存在 (x′,y′)(x&#x27;,y&#x27;)(x′,y′) 满足 ax′=ax ay′=aya_{x&#x27;}=a_x~~a_{y&#x27;}=a_yax′​=ax​ ay′​=ay​ Analysis 分析 令： preipre_iprei​ 为 aia_iai​ 这个颜色在 iii 前第一次出现的下标。 lstilst_ilsti​ 为 aia_iai​ 这个颜色最后一次出现的下标。 由反证法易得：我们选出来的 x,yx,yx,y 只有可能是某种颜色的第一次出现的位置和最后出现的位置。同时还必须满足 prey&lt;xpre_y&lt;xprey​&lt;x 且 yyy 在区间 (r,n](r,n](r,n] 只出现一次，xxx 在区间 [1,l)[1,l)[1,l) 只出现过一次。 Solution 从小到大枚举 yyy，开一个 set 维护维护在 [1,l)[1,l)[1,l) 出现一次的 xxx。到区间 (r,n](r,n](r,n] 选一个只出现过一次的 yyy 后，再从 set 中找到一个最大的下标并更新答案。记得判断无解。 Code 代码 int n,l,r,ans=inf;int a[N],pre[N],lst[N],now[N];//如题解意思，now 是为了方便清除 setint v[N];// v[i]=a[i] 在区间 (r,n] 第一次出现，用来判断是不是唯一出现。set&lt;int&gt; s;int main()&#123; read(n,l,r); for(rint i=1;i&lt;=n;i++)&#123; read(a[i]); pre[i]=lst[a[i]];lst[a[i]]=i; if(i&gt;r &amp;&amp; !v[a[i]]) v[a[i]]=i; &#125; for(rint i=1;i&lt;=n;i++)&#123; if(i&lt;l &amp;&amp; !now[a[i]]) s.insert(i); else if(s.find(now[a[i]])!=s.end()) s.erase(now[a[i]]); if(!now[a[i]]) now[a[i]]=i; if(i&gt;r &amp;&amp; v[a[i]]==i &amp;&amp; i==lst[a[i]] &amp;&amp; s.size())&#123; int t=*(--s.end()); if(t&gt;=pre[i]) ans=min(ans,i-t+1); &#125; &#125; if(ans==inf) ans=-1; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 后记 该方法常数较大，请开 O2。如有不开 O2 的方法，请私信我谢谢。","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[],"author":"Mr.Az"},{"title":"题解：P9149 串串题","slug":"题解：P9149 串串题","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P9149 串串题/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP9149%20%E4%B8%B2%E4%B8%B2%E9%A2%98/","excerpt":"","text":"Question 问题 P9149 串串题 更好的体验 Describe 题目描述 给定长度分别为 n,mn,mn,m 的整数序列 A,BA,BA,B 和常数 W,dW,dW,d，序列从 111 开始标号，保证 Ai,Bi∈[1,W]A_i,B_i \\in [1,W]Ai​,Bi​∈[1,W]。 定义权值为我们删去 AAA 中出现的对应的 ddd 种整数，令此时序列 BBB 在序列 AAA 中的出现次数。 你需要求所有的选择方案的权值和，对 109+7{10}^9+7109+7 取模。 请注意：我们并不会删除序列 BBB 中出现的对应整数。 Analysis 分析 观察题目我们会发现在 B 序列中出现的数比较特殊，若我们在 A 中删去的整数未在 B 序列中出现过，那他对我们目前匹配上的地方并不会造成任何影响。 我们这里记 A 序列中在 B 出现过的整数为重要的数，相反则为不重要的数。 所以我们可以把重要的数单独提取出来，记为 C 序列。 我们需要在 C 序列中匹配 B 序列，可以考虑使用 KMP 算法。令 [l,r] 为一段合法区间。 接下来只需要在 C 序列中枚举 B 序列出现的地方，同时我们对应到原序列 A 中。那么，[l,r] 里出现的不重要的数肯定要被删掉，相反地，这段区间内重要的数是一定不能被删除的。 设 a 是 [l,r] 内不重要的数，b 是 B 序列中数的种类，则此次方案（这段区间）的权值或者说对答案的贡献为 C(w−a−bd−a)C\\tbinom{w-a-b}{d-a}C(d−aw−a−b​)。 之后只需要统计这些合法区间中不重要的数，然后计算相应的贡献。 记住取模。 Code 代码 请自行训练写代码能力，若十分需要，可以咨询本人。","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://volantis.js.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数论","slug":"数论","permalink":"https://volantis.js.org/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://volantis.js.org/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"KMP","slug":"kmp","permalink":"https://volantis.js.org/tags/kmp/"}],"author":"Mr.Az"},{"title":"题解：P9208 虚人「无」","slug":"题解：P9208 虚人「无」","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P9208 虚人「无」/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP9208%20%E8%99%9A%E4%BA%BA%E3%80%8C%E6%97%A0%E3%80%8D/","excerpt":"","text":"Question 问题 P9208 虚人「无」 给定二元序列 {(vi,ci)}\\{(v_i,c_i)\\}{(vi​,ci​)} 和一棵以 111 为根的有根树。第 iii 个点的点权是 (vi,ci)(v_i,c_i)(vi​,ci​)。 定义一个非根节点的权值为其子树内的 ccc 的积乘上其子树补的 vvv 的积。 定义一个根节点的权值为其子树内的 ccc 的积。 形式化的讲，若 uuu 不为根节点，则 uuu 的权值 fuf_ufu​ 为： fu=∏v∈substree⁡(u)cv×∏v∉substree⁡(u)vvf_u=\\prod\\limits_{v\\in \\operatorname{substree}(u)} c_v\\times \\prod\\limits_{v\\notin \\operatorname{substree}(u)} v_v fu​=v∈substree(u)∏​cv​×v∈/substree(u)∏​vv​ 否则，其权值 fuf_ufu​ 为： fu=∏v=1ncvf_u=\\prod\\limits_{v=1}^n c_v fu​=v=1∏n​cv​ 试求整棵树所有节点的权值之和，答案对 mmm 取模。请注意：保证 m\\bm mm 是质数。 Analysis 分析 定义： dfnxdfn_xdfnx​ 为 xxx 的 dfsdfsdfs 序。 sizxsiz_xsizx​ 为 xxx 的子树大小。 先讲正解：dfs 序 &amp; 线段树查询 我们跑一遍 dfsdfsdfs 序之后，思考对于一个点 xxx，其子节点所在的 dfsdfsdfs 序必然在区间 dfnx∼dfnx+sizx−1dfn_{x} \\sim dfn_{x}+siz_{x}-1dfnx​∼dfnx​+sizx​−1 之中。 接下来我们只需要维护区间内 c,vc,vc,v 的乘积，显然我们只需要用线段树维护一下乘积就行了。 以下是错解：逆元(可选择不看) 考虑一个非常自然就能想到的方法，看到取模，想用逆元。但是在本题不行。因为使用逆元需要当所有参与计算答案的值均存在逆元，即模数 m⊥ci,vim \\perp c_i,v_im⊥ci​,vi​。 所以这道题可以通过特殊构造卡掉逆元做法。 Code 代码 #include&lt;bits/stdc++.h&gt;#define rint register int#define ls (p&lt;&lt;1)#define rs (p&lt;&lt;1|1)using namespace std;typedef long long ll;const int N=3e5+8;int n,x,y,tot,cnt,mod;int head[N],siz[N],dfn[N];ll c[N],v[N],ans;struct edge&#123; int nxt,to;&#125;e[N&lt;&lt;1];struct tree&#123; int l,r; ll csum,vsum; #define l(p) t[p].l #define r(p) t[p].r #define cs(p) t[p].csum #define vs(p) t[p].vsum&#125;t[N&lt;&lt;2];inline void add(int a,int b)&#123;e[++tot]=&#123;head[a],b&#125;;head[a]=tot;&#125;inline void add(int a,int b,string s)&#123;add(a,b);add(b,a);&#125;inline void dfs(int x,int fa)&#123; siz[x]=1;dfn[x]=++cnt; for(rint i=head[x];i;i=e[i].nxt)&#123; int y=e[i].to; if(y!=fa)&#123; dfs(y,x); siz[x]+=siz[y]; &#125; &#125;&#125;void build(int p,int l,int r)&#123; l(p)=l;r(p)=r; if(l==r)&#123;cs(p)=c[l],vs(p)=v[l];return;&#125; int Mid=l+r&gt;&gt;1; build(ls,l,Mid),build(rs,Mid+1,r); cs(p)=cs(ls)*cs(rs)%mod; vs(p)=vs(ls)*vs(rs)%mod; return ;&#125;ll query(int p,int l,int r,int cmd)&#123; if(l&lt;=l(p)&amp;&amp;r(p)&lt;=r)&#123; if(cmd) return vs(p); else return cs(p); &#125; ll res=1;int Mid=l(p)+r(p)&gt;&gt;1; if(l&lt;=Mid) res=query(ls,l,r,cmd); if(r&gt;Mid) res=res*query(rs,l,r,cmd)%mod; return res;&#125;int main()&#123; read(n,mod); for(rint i=1;i&lt;n;i++) read(x,y),add(x,y,&quot;Mr.Az&quot;); dfs(1,0); for(rint i=1;i&lt;=n;i++) read(c[dfn[i]]); for(rint i=1;i&lt;=n;i++) read(v[dfn[i]]); build(1,1,n); for(rint i=1;i&lt;=n;i++)&#123; ll res=1; if(dfn[i]!=1) res=query(1,1,dfn[i]-1,1); res=res*query(1,dfn[i],dfn[i]+siz[i]-1,0)%mod; if(dfn[i]+siz[i]&lt;=n) res=res*query(1,dfn[i]+siz[i],n,1)%mod; ans=(ans+res)%mod; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"dfs 序","slug":"dfs-序","permalink":"https://volantis.js.org/tags/dfs-%E5%BA%8F/"}],"author":"Mr.Az"},{"title":"题解：P9915 「RiOI-03」3-2","slug":"题解：P9915 「RiOI-03」3-2","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P9915 「RiOI-03」3-2/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP9915%20%E3%80%8CRiOI-03%E3%80%8D3-2/","excerpt":"","text":"Question 问题 P9915 「RiOI-03」3-2 给定一个正整数 nnn。将 [0,2n)[0,2^n)[0,2n) 中每个整数的二进制最低 nnn 位从低到高依次写在一个 2n×n2^n\\times n2n×n 的矩阵上。矩阵两维的下标都从 000 开始。 如，当 n=3n=3n=3 时，矩阵是这样的： 给定 qqq 次询问，每次询问这个矩阵下标为 (x,y)(x,y)(x,y) 的格子所在的四连通块大小对 998244353998244353998244353 取模的值。 Solution 数学（观察性质） 应该是本题最简单，容易理解和实现的方法。 首先判断这个位置 (x,y)(x,y)(x,y) 是否为 1 or 01~\\text{or}~01 or 0 是简单的，(x&gt;&gt;y)&amp;1 即可。 打表观察方案，发现连通块大小必然是 2m−12^m-12m−1，简要证明：观察到每个连通块都可以拆成 ∑i=0m2i\\sum_{i=0}^{m} 2^i∑i=0m​2i，该式子的值为：2m+12^{m+1}2m+1。 同时由上面的简要证明可知，从当前位置开始往右走，假设到 (x,r)(x,r)(x,r) 时与原位置的数不一致或者向右走出表格外（此时 r=nr=nr=n），那么当前位置所处的连通块的大小即为 2r−12^r-12r−1。 一个优化：在 y≥60y \\ge 60y≥60 时，直接输出 2n−12^n-12n−1 即可，因为此时该位置必然处于最大连通块。同时也避免了 2y2^y2y 超出 long long 范围的错误（准确来说，这是未定义行为）。 Code 代码 int n,q;ll x,y;inline ll two(int p)&#123; ll res=1,a=2; while(p)&#123; if(p&amp;1) res=res*a%mod; a=a*a%mod; p&gt;&gt;=1; &#125; return res%mod;&#125;//2^n 快速幂inline bool check(ll x,ll y)&#123;return ((x&gt;&gt;y)&amp;1);&#125;//改位置为1或0signed main()&#123; read(n,q);ll num=two(n); for(rint i=1;i&lt;=q;i++)&#123; read(x,y); if(y&gt;=60)&#123;//特判 printf(&quot;%lld\\n&quot;,num-1); continue; &#125; int t=check(x,y);//当前位置的数 while(check(x,y)==t&amp;&amp;y&lt;n) y++;//若不同则停止，相同则往右走 printf(&quot;%lld\\n&quot;,two(y)-1);//y不需要-1，请自行思考原因 &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://volantis.js.org/tags/%E6%95%B0%E5%AD%A6/"}],"author":"Mr.Az"},{"title":"题解：SP34032 INTDSET - Chiaki With Intervals","slug":"题解：SP34032 INTDSET - Chiaki With Intervals","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：SP34032 INTDSET - Chiaki With Intervals/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ASP34032%20INTDSET%20-%20Chiaki%20With%20Intervals/","excerpt":"","text":"SP34032 INTDSET - Chiaki With Intervals Solution: 简单版本 题意：在一些区间中选择一些区间，使得其余区间均有与被选择的区间有交。 首先将所有的区间按照右端点从小到大排序，依次选择。 考虑 DP，设计 DP 状态 dpi,jdp_{i,j}dpi,j​ 表示当前已经考虑了前 iii 个区间，与 1−j1-j1−j 区间均有交的方案数。 考虑转移，如果当前第 iii 个区间不选择，则 dpi,j←dpi−1,jdp_{i,j} \\leftarrow dp_{i-1,j}dpi,j​←dpi−1,j​。 如果选择第 iii 个区间，我们考虑该区间往左边和往右边最远的与其有交的区间，记作 Li,RiL_i,R_iLi​,Ri​，这个东西分别可以通过二分和双指针简单处理得到。那么转移就为： {dpi,Ri←∑j∈[Li−1,n]dpi−1,jdpi,j←dpi−1,j(j∉[Li−1,n])\\begin{cases} dp_{i,R_i} \\leftarrow \\displaystyle\\sum_{j \\in [L_i-1,n]} dp_{i-1,j}\\\\ dp_{i,j} \\leftarrow dp_{i-1,j}(j \\notin [L_i-1,n]) \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​dpi,Ri​​←j∈[Li​−1,n]∑​dpi−1,j​dpi,j​←dpi−1,j​(j∈/[Li​−1,n])​ 第一个转移很好理解，在这个区间里的 kkk 在经过选择了第 iii 个区间后可以直接转移到第 RiR_iRi​ 个区间，反之，选择了之后中间仍有空缺，所以有效的部分仍然还是在 kkk，但是这与上面不选择是两种情况，所以相当于 ×2\\times 2×2。 线段树维护第二维即可，只需要支持单点加，区间 ×2\\times 2×2，区间查询和即可。 Code: const int N=2e5+8,mod=1e9+7;int n;int two[N],L[N],R[N];struct seq&#123;int l,r;&#125;a[N];struct tree&#123; int x,lazy; #define x(p) t[p].x #define lazy(p) t[p].lazy&#125;t[N*4];#define mid (l+r&gt;&gt;1)inline int md(int x)&#123; if(x&lt;0) return x+mod; if(x&gt;=mod) return x-mod; return x;&#125;void build(int p,int l,int r)&#123; x(p)=lazy(p)=0; if(l==r) return ; build(ls,l,mid);build(rs,mid+1,r);&#125;inline void update(int p)&#123;x(p)=md(x(ls)+x(rs));&#125;inline void spread(int p)&#123; if(lazy(p))&#123; x(ls)=x(ls)*two[lazy(p)]%mod; x(rs)=x(rs)*two[lazy(p)]%mod; lazy(ls)+=lazy(p); lazy(rs)+=lazy(p); lazy(p)=0; &#125; return ;&#125;void add(int p,int l,int r,int pos,int k)&#123; if(l==r&amp;&amp;l==pos)&#123;x(p)=md(x(p)+k);return ;&#125; spread(p); if(pos&lt;=mid) add(ls,l,mid,pos,k); else add(rs,mid+1,r,pos,k); update(p); return ;&#125;void mul(int p,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;x(p)=md(x(p)*2),lazy(p)++;return ;&#125; spread(p); if(L&lt;=mid) mul(ls,l,mid,L,R); if(R&gt;mid) mul(rs,mid+1,r,L,R); update(p); return ; &#125;int ask(int p,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return x(p); spread(p); int res=0; if(L&lt;=mid) res=md(res+ask(ls,l,mid,L,R)); if(R&gt;mid) res=md(res+ask(rs,mid+1,r,L,R)); return res;&#125;#undef midint T;inline void solve()&#123; read(n); for(rint i=1;i&lt;=n;i++) read(a[i].l,a[i].r); build(1,0,n); sort(a+1,a+n+1,[](seq A,seq B)&#123;return A.r&lt;B.r;&#125;); for(rint i=1;i&lt;=n;i++)&#123; int l=1,r=i; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid].r&gt;=a[i].l) r=mid; else l=mid+1; &#125; L[i]=l; &#125; for(int i=1,j=1;i&lt;=n;i++)&#123; while(j&lt;n&amp;&amp;a[j+1].l&lt;=a[i].r) j++; R[i]=j; &#125; add(1,0,n,0,1); for(rint i=1;i&lt;=n;i++)&#123; add(1,0,n,R[i],ask(1,0,n,L[i]-1,n)); if(L[i]&gt;1) mul(1,0,n,0,L[i]-2); &#125; cout&lt;&lt;ask(1,0,n,n,n)&lt;&lt;endl;&#125;signed main()&#123; two[0]=1; for(rint i=1;i&lt;=N-8;i++) two[i]=md(two[i-1]*2); read(T); while(T--) solve(); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"线段树优化 DP","slug":"线段树优化-dp","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96-dp/"},{"name":"动态规划 DP","slug":"动态规划-dp","permalink":"https://volantis.js.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/"}],"author":"Mr.Az"},{"title":"题解：SP34063 INTDSET2 - Chiaki With Intervals (Easy)","slug":"题解：SP34063 INTDSET2 - Chiaki With Intervals (Easy)","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：SP34063 INTDSET2 - Chiaki With Intervals (Easy)/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ASP34063%20INTDSET2%20-%20Chiaki%20With%20Intervals%20(Easy)/","excerpt":"","text":"INTDSET2 - Chiaki With Intervals (Easy) Solution: 困难版本 题意：在一些区间中选择一些区间，使得其余区间均有与被选择的区间有交。 首先将所有的区间按照右端点从小到大排序，依次选择。 考虑 DP，设计 DP 状态 dpi,jdp_{i,j}dpi,j​ 表示当前已经考虑了前 iii 个区间，与 1−j1-j1−j 区间均有交的方案数。 考虑转移，如果当前第 iii 个区间不选择，则 dpi,j←dpi−1,jdp_{i,j} \\leftarrow dp_{i-1,j}dpi,j​←dpi−1,j​。 如果选择第 iii 个区间，我们考虑该区间往左边和往右边最远的与其有交的区间，记作 Li,RiL_i,R_iLi​,Ri​，这个东西分别可以通过二分和双指针简单处理得到。那么转移就为： {dpi,Ri←∑j∈[Li−1,n]dpi−1,jdpi,j←dpi−1,j(j∉[Li−1,n])\\begin{cases} dp_{i,R_i} \\leftarrow \\displaystyle\\sum_{j \\in [L_i-1,n]} dp_{i-1,j}\\\\ dp_{i,j} \\leftarrow dp_{i-1,j}(j \\notin [L_i-1,n]) \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​dpi,Ri​​←j∈[Li​−1,n]∑​dpi−1,j​dpi,j​←dpi−1,j​(j∈/[Li​−1,n])​ 第一个转移很好理解，在这个区间里的 kkk 在经过选择了第 iii 个区间后可以直接转移到第 RiR_iRi​ 个区间，反之，选择了之后中间仍有空缺，所以有效的部分仍然还是在 kkk，但是这与上面不选择是两种情况，所以相当于 ×2\\times 2×2。 线段树维护第二维即可，只需要支持单点加，区间 ×2\\times 2×2，区间查询和即可。 Code: const int N=2e5+8,mod=1e9+7;int n;int two[N],L[N],R[N];struct seq&#123;int l,r;&#125;a[N];struct tree&#123; int x,lazy; #define x(p) t[p].x #define lazy(p) t[p].lazy&#125;t[N*4];#define mid (l+r&gt;&gt;1)inline int md(int x)&#123; if(x&lt;0) return x+mod; if(x&gt;=mod) return x-mod; return x;&#125;void build(int p,int l,int r)&#123; x(p)=lazy(p)=0; if(l==r) return ; build(ls,l,mid);build(rs,mid+1,r);&#125;inline void update(int p)&#123;x(p)=md(x(ls)+x(rs));&#125;inline void spread(int p)&#123; if(lazy(p))&#123; x(ls)=x(ls)*two[lazy(p)]%mod; x(rs)=x(rs)*two[lazy(p)]%mod; lazy(ls)+=lazy(p); lazy(rs)+=lazy(p); lazy(p)=0; &#125; return ;&#125;void add(int p,int l,int r,int pos,int k)&#123; if(l==r&amp;&amp;l==pos)&#123;x(p)=md(x(p)+k);return ;&#125; spread(p); if(pos&lt;=mid) add(ls,l,mid,pos,k); else add(rs,mid+1,r,pos,k); update(p); return ;&#125;void mul(int p,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;x(p)=md(x(p)*2),lazy(p)++;return ;&#125; spread(p); if(L&lt;=mid) mul(ls,l,mid,L,R); if(R&gt;mid) mul(rs,mid+1,r,L,R); update(p); return ; &#125;int ask(int p,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return x(p); spread(p); int res=0; if(L&lt;=mid) res=md(res+ask(ls,l,mid,L,R)); if(R&gt;mid) res=md(res+ask(rs,mid+1,r,L,R)); return res;&#125;#undef midint T;inline void solve()&#123; read(n); for(rint i=1;i&lt;=n;i++) read(a[i].l,a[i].r); build(1,0,n); sort(a+1,a+n+1,[](seq A,seq B)&#123;return A.r&lt;B.r;&#125;); for(rint i=1;i&lt;=n;i++)&#123; int l=1,r=i; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid].r&gt;=a[i].l) r=mid; else l=mid+1; &#125; L[i]=l; &#125; for(int i=1,j=1;i&lt;=n;i++)&#123; while(j&lt;n&amp;&amp;a[j+1].l&lt;=a[i].r) j++; R[i]=j; &#125; add(1,0,n,0,1); for(rint i=1;i&lt;=n;i++)&#123; add(1,0,n,R[i],ask(1,0,n,L[i]-1,n)); if(L[i]&gt;1) mul(1,0,n,0,L[i]-2); &#125; cout&lt;&lt;ask(1,0,n,n,n)&lt;&lt;endl;&#125;signed main()&#123; two[0]=1; for(rint i=1;i&lt;=N-8;i++) two[i]=md(two[i-1]*2); read(T); while(T--) solve(); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"线段树优化 DP","slug":"线段树优化-dp","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96-dp/"},{"name":"动态规划 DP","slug":"动态规划-dp","permalink":"https://volantis.js.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/"}],"author":"Mr.Az"},{"title":"题解：「PumpkinOI Round 1 T1 瓦解」","slug":"题解：「PumpkinOI Round 1 T1 瓦解」","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：「PumpkinOI Round 1 T1 瓦解」/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9A%E3%80%8CPumpkinOI%20Round%201%20T1%20%E7%93%A6%E8%A7%A3%E3%80%8D/","excerpt":"","text":"PumpkinOI Round 1 T1 瓦解 验题人题解。 标签：组合数学，线性预处理逆元 Solution: 把问题转化为在 n−1n-1n−1 个间隔至多选 m−1m-1m−1 个切断的合法方案数。 首先考虑满足题目要求的情况下至少需要分成多少段。容易发现 ∀i∈[1,n) ai≥ai+1\\forall_{i\\in[1,n)}~ a_i \\ge a_{i+1}∀i∈[1,n)​ ai​≥ai+1​，第 iii 个数与第 i+1i+1i+1 个数之间，至少要分一段，否则不符合题目要求的每一段都严格递增。 设有 cntcntcnt 处不合法的位置（即 ai≥ai+1a_i \\ge a_{i+1}ai​≥ai+1​ 的位置）。，则问题变为在 n−cnt−1n-cnt-1n−cnt−1 个间隔至多选 m−cnt−1m-cnt-1m−cnt−1 个切断的合法方案数，即： ∑i=0m−cnt−1Cn−cnt−1i\\sum_{i=0}^{m-cnt-1} C_{n-cnt-1}^{i} i=0∑m−cnt−1​Cn−cnt−1i​ 由于 ∑n≤107\\sum n \\le 10^7∑n≤107，所以我们直接枚举求和即可。 组合数需要预处理逆元。 Code: const int N=1e7+8,mod=998244353;int T,n,m,pre,now,cnt;int jie[N],inv[N];inline void init()&#123; inv[0]=inv[1]=jie[0]=jie[1]=1; for(int i=2;i&lt;=N-8;i++)&#123; jie[i]=jie[i-1]*i%mod; inv[i]=inv[mod%i]*(mod-mod/i)%mod; &#125; for(int i=2;i&lt;=N-8;i++) inv[i]=inv[i-1]*inv[i]%mod;&#125;inline int C(int n,int m)&#123;return jie[n]*inv[m]%mod*inv[n-m]%mod;&#125;signed main()&#123; init();//预处理阶乘、逆元 用来计算组合数 read(T); while(T--)&#123; read(n,m,pre);cnt=0; for(int i=1;i&lt;n;i++)&#123; read(now); if(pre&gt;=now) cnt++;//不合法的地方数量 pre=now; &#125; int res=0; for(int i=0;i&lt;=m-cnt-1;i++) res=(res+C(n-cnt-1,i))%mod;//枚举计算 printf(&quot;%lld\\n&quot;,res); &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://volantis.js.org/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","permalink":"https://volantis.js.org/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"author":"Mr.Az"},{"title":"题解：「PumpkinOI Round 1 T4 种南瓜」","slug":"题解：「PumpkinOI Round 1 T4 种南瓜」","date":"2025-05-26T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：「PumpkinOI Round 1 T4 种南瓜」/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9A%E3%80%8CPumpkinOI%20Round%201%20T4%20%E7%A7%8D%E5%8D%97%E7%93%9C%E3%80%8D/","excerpt":"","text":"PumpkinOI Round 1 T4 种南瓜 验题人题解。 标签：线段树分治 Solution: 考虑没有删除操作时如何维护答案，即每次加入一个区间 [l,r][l,r][l,r]。不合法的情况当且仅当加入的时候，之前存在有区间与当前 [l,r][l,r][l,r] 有交且不包含，这是一个经典的二维偏序问题。只需要用两颗线段树分别维护以此处为右端点最大的左端点和以此处为左端点的最小右端点判断即可。支持区间取 max⁡/min⁡\\max/\\minmax/min，单点查询即可。 考虑加入删除操作，我们会发现每一个加区间操作影响的是一段时间区间，考虑线段树分治。 我们对时间这一维建一颗线段树，树的每一个节点存储的信息是在这个时间区间内的操作区间。求答案只需要遍历整颗线段树，维护两颗线段树，每次进入一个节点的时候把所有区间全部加进去，直到叶子结点。这样我们就可以保证在走到叶子结点的时候，两颗线段树里全都是在这一段时间存在的操作区间的影响。 如果此时仍然没有出现矛盾，则在这个时间时刻是合法的。但如果在加区间的过程中出现了不合法的情况，那么这一个时间时刻是不合法的。对应的输出即可。 一个小优化，如果在走到一个节点（维护的时间区间是 [l,r][l,r][l,r]）时已经出现了矛盾，则说明 [l,r][l,r][l,r] 这段时间内的所有操作全部都是不合法的。此时直接跳出即可。 对于离开这个节点的撤销操作，只需要维护一个栈存储线段树内哪些点被修改了以及其原来的值，离开的时候回溯成进入该节点时的状态即可。 时间复杂度 遍历线段树复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)，每一个节点内用线段树判断合法复杂度 O(log⁡n)O(\\log n)O(logn)，则总时间复杂度为 O(nlog⁡2n)O(n \\log^2 n)O(nlog2n)。 Code: int n,m,q;int pos[N];struct node&#123;int l,r,L,R;&#125;;vector&lt;node&gt; a;#define mid (l+r&gt;&gt;1)namespace mx&#123;//维护区间最大值 支持区间取 max，单点查询 vector&lt;pii&gt; cl; struct tree&#123; int val; #define val(p) t[p].val &#125;t[N*4]; inline void clear(int p)&#123; while(cl.size()&gt;p)&#123; auto [x,y]=cl[cl.size()-1];cl.pop_back(); val(x)=y; &#125; &#125;//撤销操作 inline void cg(int p,int k)&#123;if(val(p)&lt;k) cl.pb(&#123;p,val(p)&#125;),val(p)=k;&#125; inline void spread(int p)&#123; if(val(p))&#123; cg(ls,val(p)),cg(rs,val(p)); cl.pb(&#123;p,val(p)&#125;),val(p)=0; &#125; &#125; void change(int p,int l,int r,int L,int R,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;cg(p,k);return ;&#125; spread(p); if(L&lt;=mid) change(ls,l,mid,L,R,k); if(R&gt;mid) change(rs,mid+1,r,L,R,k); return ; &#125; int ask(int p,int l,int r,int pos)&#123; if(l==r&amp;&amp;l==pos) return val(p); int res=0; spread(p); if(pos&lt;=mid) res=ask(ls,l,mid,pos); else res=max(res,ask(rs,mid+1,r,pos)); return res; &#125; #undef val&#125;namespace mn&#123;//维护区间最小值 支持区间取 min，单点查询 vector&lt;pii&gt; cl; struct tree&#123; int val; #define val(p) t[p].val &#125;t[N*4]; inline void build(int p,int l,int r)&#123; val(p)=INF; if(l==r) return ; build(ls,l,mid);build(rs,mid+1,r); &#125; inline void clear(int p)&#123; while(cl.size()&gt;p)&#123; auto [x,y]=cl[cl.size()-1];cl.pop_back(); val(x)=y; &#125; &#125;//撤销操作 inline void cg(int p,int k)&#123;if(val(p)&gt;k) cl.pb(&#123;p,val(p)&#125;),val(p)=k;&#125; inline void spread(int p)&#123; if(val(p)!=INF)&#123; cg(ls,val(p)),cg(rs,val(p)); cl.pb(&#123;p,val(p)&#125;),val(p)=INF; &#125; &#125; void change(int p,int l,int r,int L,int R,int k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;cg(p,k);return ;&#125; spread(p); if(L&lt;=mid) change(ls,l,mid,L,R,k); if(R&gt;mid) change(rs,mid+1,r,L,R,k); return ; &#125; int ask(int p,int l,int r,int pos)&#123; if(l==r&amp;&amp;l==pos) return val(p); int res=INF; spread(p); if(pos&lt;=mid) res=ask(ls,l,mid,pos); else res=min(res,ask(rs,mid+1,r,pos)); return res; &#125; #undef val&#125;struct tree&#123; vector&lt;pii&gt; a; #define sq(p) t[p].a&#125;t[N*4];void add(int p,int l,int r,int L,int R,pii a)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;sq(p).pb(a);return ;&#125; if(L&lt;=mid) add(ls,l,mid,L,R,a); if(R&gt;mid) add(rs,mid+1,r,L,R,a); return ;&#125; void ask(int p,int l,int r)&#123; int mx1=mx::cl.size(),mn1=mn::cl.size();//初始栈的状态 for(auto [ll,rr]:sq(p))&#123; if(ll!=rr)&#123; int t1=mx::ask(1,1,n,rr),t2=mn::ask(1,1,n,ll); if(ll&lt;t1||rr&gt;t2)&#123; for(rint i=l;i&lt;=r;i++) puts(&quot;No&quot;); goto clean; &#125;//在其中某一处不合法的时候，直接对于 [l,r] 全部输出 No mx::change(1,1,n,ll,rr-1,ll); mn::change(1,1,n,ll+1,rr,rr); &#125; &#125; if(l==r) puts(&quot;Yes&quot;);//到叶子结点都合法，则输出 Yes else&#123; ask(ls,l,mid); ask(rs,mid+1,r); &#125; clean: mx::clear(mx1);mn::clear(mn1);//回溯&#125;#undef sq#undef midsigned main()&#123; read(n,q); for(rint i=1,op,l,r;i&lt;=q;i++)&#123; read(op); if(op==1)&#123; read(l,r); a.pb(&#123;l,r,i,q&#125;); pos[i]=m;m++; &#125; else&#123; read(l); a[pos[l]].R=i-1; &#125; &#125; for(auto [l,r,L,R]:a) add(1,1,q,L,R,&#123;l,r&#125;);//存在时间区间 [L,R]，操作区间 [l,r] mn::build(1,1,n);//最小值线段树初始化为 inf ask(1,1,q); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"线段树分治","slug":"线段树分治","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"}],"author":"Mr.Az"},{"title":"题解：AT_abc394_g [ABC394G] Dense Buildings","slug":"题解：AT_abc394_g [ABC394G] Dense Buildings","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：AT_abc394_g [ABC394G] Dense Buildings/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_abc394_g%20[ABC394G]%20Dense%20Buildings/","excerpt":"","text":"AT_abc394_g [ABC394G] Dense Buildings Algorithm: 最大生成树 + 倍增LCA / 树剖。 Solution: 题目中横跨两个大楼之间的次数并不重要，原题目的意思转为每次可以从当前楼找一条通向终点的路径使得路径上的楼房高度最小值最大。 看到最小值最大会先想到二分答案，考虑如何 check，也就是我现在只能走到大于当前二分的值 xxx 的楼，求是否有一条路径可以从起点走向终点。容易发现这是最大生成树，边权即为两端点权的较小者。维护路径上的最小值可以用倍增 LCA 或者树链剖分，笔者选择了后者。 Code: const int M=508,N=M*M,dx[]=&#123;1,-1,0,0&#125;,dy[]=&#123;0,0,1,-1&#125;;int T=1;int n,m,q,ddfn;int a[N],fa[N],dfn[N],num[N],dep[N],siz[N],top[N],son[N];vector&lt;int&gt; e[N];struct edge&#123;int u,v,w;&#125;;inline int id(int x,int y)&#123;return (x-1)*m+y;&#125;inline bool valid(int x,int y)&#123;return x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m;&#125;inline int getfa(int x)&#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;vector&lt;edge&gt; ed;struct tree&#123; int mn; #define mn(p) t[p].mn&#125;t[N*4];#define mid (l+r&gt;&gt;1)inline void update(int p)&#123;mn(p)=min(mn(ls),mn(rs));&#125;void build(int p,int l,int r)&#123; if(l==r)&#123;mn(p)=a[num[l]];return ;&#125; build(ls,l,mid);build(rs,mid+1,r); update(p); return ;&#125;int ask(int p,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return mn(p); int res=INF; if(L&lt;=mid) res=min(res,ask(ls,l,mid,L,R)); if(R&gt;mid) res=min(res,ask(rs,mid+1,r,L,R)); return res; &#125;#undef mn#undef midvoid dfs(int u,int faa)&#123; dep[u]=dep[faa]+1;siz[u]=1;fa[u]=faa; int mx=0; for(auto v:e[u])&#123; if(v==faa) continue; dfs(v,u); if(mx&lt;siz[v]) mx=siz[v],son[u]=v; siz[u]+=siz[v]; &#125;&#125;void dfs1(int u,int fa,int t)&#123; top[u]=t;dfn[u]=++ddfn;num[dfn[u]]=u; if(son[u]) dfs1(son[u],u,t); for(auto v:e[u])&#123; if(v!=fa&amp;&amp;v!=son[u]) dfs1(v,u,v); &#125;&#125;int ask(int x,int y)&#123; int res=INF; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=min(res,ask(1,1,n*m,dfn[top[x]],dfn[x])); debug(x,y,ask(1,1,n*m,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); res=min(res,ask(1,1,n*m,dfn[x],dfn[y])); debug(x,y,ask(1,1,n*m,dfn[x],dfn[y])); return res;&#125;inline void solve()&#123; read(n,m); for(rint i=1;i&lt;=n*m;i++) fa[i]=i; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=m;j++)&#123; read(a[id(i,j)]); &#125; &#125; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=m;j++)&#123; for(rint k=0;k&lt;4;k++)&#123; int nx=i+dx[k],ny=j+dy[k]; if(valid(nx,ny))&#123; ed.pb(&#123;id(i,j),id(nx,ny),min(a[id(i,j)],a[id(nx,ny)])&#125;); &#125; &#125; &#125; &#125; sort(alls(ed),[](edge A,edge B)&#123;return A.w&gt;B.w;&#125;); for(auto [u,v,w]:ed)&#123; int fu=getfa(u),fv=getfa(v); if(fu!=fv)&#123; fa[fu]=fv; e[u].pb(v);e[v].pb(u); debug(u,v); &#125; &#125; mem(fa,0); dfs(1,0);dfs1(1,0,1); build(1,1,n*m); read(q); while(q--)&#123; int x,y,xx,yy,a1,a2,ans=0; read(x,y,a1,xx,yy,a2); int o=ask(id(x,y),id(xx,yy)); ans=a1-min(&#123;a1,a2,o&#125;); ans+=a2-min(&#123;a1,a2,o&#125;); printf(&quot;%lld\\n&quot;,ans); &#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"最大生成树","slug":"最大生成树","permalink":"https://volantis.js.org/tags/%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"LCA","slug":"lca","permalink":"https://volantis.js.org/tags/lca/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://volantis.js.org/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"author":"Mr.Az"},{"title":"题解：AT_abc394_f [ABC394F] Alkane","slug":"题解：AT_abc394_f [ABC394F] Alkane","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：AT_abc394_f [ABC394F] Alkane/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_abc394_f%20[ABC394F]%20Alkane/","excerpt":"","text":"AT_abc394_f [ABC394F] Alkane Algorithm: 树形 DP。 Solution: 无解是好判断的，直接记录每个点的度数，看有没有至少一个点的度数大于等于 444 即可。 考虑通过树形 DP 解决这个问题，需要注意与父亲连接的边也算一个度数，所以我们可以设计出一下状态： fu,x,0/1f_{u,x,0/1}fu,x,0/1​ 表示当前 uuu 的度数为 xxx，在 uuu 的子树内是否已经有了度数为 444 的点时，拥有的最多的点的数量。 考虑如何转移（笔者想了半天，结果是个简单的 DP）。 注意到加粗部分，所以从下转移上来的儿子的度数只能是 000 或者 333 。我们额外记一个 gx,0/1g_{x,0/1}gx,0/1​ 代表我们当前的度数为 xxx ，子树中是否已经出现过度数为 444 的点。转移类似背包。 Code: const int N=2e5+8;int n,ans;int f[N][6][3],deg[N],g[6][3];vector&lt;int&gt; e[N];void dfs(int u,int fa)&#123; for(rint i=0;i&lt;=4;i++) f[u][i][0]=f[u][i][1]=-inf; f[u][0][0]=1;f[u][0][1]=0; for(auto v:e[u])&#123; if(v==fa) continue; dfs(v,u); for(rint i=0;i&lt;=4;i++) g[i][0]=f[u][i][0],g[i][1]=f[u][i][1]; for(rint i=1;i&lt;=4;i++)&#123; for(rint j=0;j&lt;=4;j++)&#123; if(j==0||j==3)&#123; g[i][0]=max(g[i][0],f[u][i-1][0]+f[v][j][0]); g[i][1]=max(g[i][1],f[u][i-1][0]+f[v][j][1]); g[i][1]=max(g[i][1],f[u][i-1][1]+f[v][j][0]); g[i][1]=max(g[i][1],f[u][i-1][1]+f[v][j][1]); if(j==3||i==4) g[i][1]=max(g[i][1],f[u][i-1][0]+f[v][j][0]); &#125; &#125; &#125; for(rint i=0;i&lt;=4;i++) f[u][i][0]=g[i][0],f[u][i][1]=g[i][1]; &#125; ans=max(&#123;ans,f[u][1][1],f[u][4][1]&#125;); return ;&#125;inline void solve()&#123; read(n); bool valid=0; for(rint i=1,u,v;i&lt;n;i++)&#123; read(u,v); e[u].pb(v),e[v].pb(u),deg[v]++,deg[u]++; valid|=(deg[v]&gt;=4||deg[u]&gt;=4); &#125; if(!valid) puts(&quot;-1&quot;),exit(0); dfs(1,0); printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"树形 DP","slug":"树形-dp","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2-dp/"}],"author":"Mr.Az"},{"title":"题解：AT_abc394_e [ABC394E] Palindromic Shortest Path","slug":"题解：AT_abc394_e [ABC394E] Palindromic Shortest Path","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：AT_abc394_e [ABC394E] Palindromic Shortest Path/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AAT_abc394_e%20[ABC394E]%20Palindromic%20Shortest%20Path/","excerpt":"","text":"AT_abc394_e [ABC394E] Palindromic Shortest Path Algorithm: 模拟。 Solution: 观察到可能的回文串非常短，可以直接模拟出来。考虑对于偶数和奇数长度的回文串，笔者的做法是直接暴力预处理出所有长度为 111 和 222 的对 (i,j)(i,j)(i,j)，拿个 vector 存下来，每次在两边扩展一样的字符。 结束的条件就是没有扩展的对了。通过这个做法也可以证明可能的回文串是有限的，因为你的每次扩展要么新扩展一个对，要么直接结束，最多匹配 1002=10000100^2=100001002=10000 次。 可能写的比较丑陋，有比较好看的实现是这样的： 先把长度为 111 和 222 的对 (i,j)(i,j)(i,j) 扔进队列里面，每次模仿最短路扩展，可能会更好看一点？本质是一样的。 Code: const int N=108;int n;int dis[N][N];char s[N][N];inline void solve()&#123; read(n); for(rint i=1;i&lt;=n;i++) for(rint j=1;j&lt;=n;j++) dis[i][j]=-1; for(rint i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,s[i]+1); dis[i][i]=0; &#125; vector&lt;pii&gt; one,two; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; if(s[i][j]==&#x27;-&#x27;||i==j) continue; dis[i][j]=1; one.pb(&#123;i,j&#125;); &#125; &#125; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; for(rint k=1;k&lt;=n;k++)&#123; if(dis[i][k]!=-1) continue; if(s[i][j]==s[j][k]&amp;&amp;s[i][j]!=&#x27;-&#x27;) dis[i][k]=2,two.pb(&#123;i,k&#125;); &#125; &#125; &#125; int now=1; while(1)&#123; bool f=1; vector&lt;pii&gt; t1,t2; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; if(dis[i][j]==-1)&#123; for(auto [x,y]:one)&#123; if(s[i][x]==s[y][j]&amp;&amp;s[i][x]!=&#x27;-&#x27;)&#123; dis[i][j]=now*2+1; t1.pb(&#123;i,j&#125;); f=0; break; &#125; &#125; &#125; &#125; &#125; one.swap(t1); for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; if(dis[i][j]==-1)&#123; for(auto [x,y]:two)&#123; if(s[i][x]==s[y][j]&amp;&amp;s[i][x]!=&#x27;-&#x27;)&#123; dis[i][j]=now*2+2; t2.pb(&#123;i,j&#125;); f=0; break; &#125; &#125; &#125; &#125; &#125; two.swap(t2); now++; if(f) break; &#125; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++) cout&lt;&lt;dis[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://volantis.js.org/tags/%E6%A8%A1%E6%8B%9F/"}],"author":"Mr.Az"},{"title":"题解：CF2064D Eating","slug":"题解：CF2064D Eating","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：CF2064D Eating/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF2064D%20Eating/","excerpt":"","text":"CF2064D Eating Algorithm: 模拟 + 拆位。 Solution: 对于 xor 的问题，首先按位进行考虑。由于我们能干掉的史莱姆权值都比我们小，所以可以很显然的观察到他们的最高位一定是小于等于我们的，并且我们的最高位在合并史莱姆的过程中只会下降。 这启示我们观察到可能使当前结束的点，最高位是大于等于当前值的最高位的。所以我们用 O(Nlog⁡V)\\text{O}(N\\log V)O(NlogV) 的时间预处理出一个 prei,jpre_{i,j}prei,j​ 数组用来存储离当前点 iii 最近的最高位大于等于当前值的最高位 jjj 的下标。而且每次跳转我们要么直接结束，要么最高位至少下降 111 位，所以每次询问的复杂度是 O(log⁡V)\\text{O}(\\log V)O(logV) 的。 时间复杂度 O((N+Q)log⁡V)\\text{O}((N+Q) \\log V)O((N+Q)logV)。 Code: const int N=2e5+8;int n,q;int a[N],nxt[N][32],sum[N];inline int get(int l,int r)&#123;return sum[r]^sum[l-1];&#125;inline void solve()&#123; read(n,q); for(rint i=1;i&lt;=n;i++) read(a[i]); for(rint i=1;i&lt;=n;i++) sum[i]=sum[i-1]^a[i]; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=0;j&lt;=30;j++)&#123; if(j&lt;=__lg(a[i])) nxt[i][j]=i; else nxt[i][j]=nxt[i-1][j]; &#125; &#125; while(q--)&#123; int x,now=n;read(x); while(now&gt;=1&amp;&amp;x&gt;0)&#123; int pos=nxt[now][__lg(x)]; if(pos==0)&#123;now=0;break;&#125; x^=get(pos+1,now); now=pos; if(x&lt;a[pos]) break; x^=a[pos]; now--; &#125; printf(&quot;%lld &quot;,n-now); end:; &#125; puts(&quot;&quot;);&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://volantis.js.org/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二进制拆位","slug":"二进制拆位","permalink":"https://volantis.js.org/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E4%BD%8D/"}],"author":"Mr.Az"},{"title":"题解：CF2064E Mycraft Sand Sort","slug":"题解：CF2064E Mycraft Sand Sort","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：CF2064E Mycraft Sand Sort/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9ACF2064E%20Mycraft%20Sand%20Sort/","excerpt":"","text":"CF2064E Mycraft Sand Sort Algorithm: 并查集合并信息。 Solution: 首先观察到颜色集合 ccc 不会发生变化，因为如果改变颜色则第一列就已经不一样了，所以变化的只有长度排列 ppp。 考虑什么时候交换两行的长度不会对最终的结果。对于两行颜色一样的行 l,r(l&lt;r)l,r(l&lt;r)l,r(l&lt;r)，他们能交换当且仅当 min⁡i=l+1r−1pi&lt;min⁡(pl,pr)\\min_{i=l+1}^{r-1} p_i&lt;\\min(p_l,p_r)mini=l+1r−1​pi​&lt;min(pl​,pr​) 或者他们相邻。需要满足前者条件是因为中间行的长度小于 plp_lpl​ 是为了不让中间的颜色掉下来，小于 prp_rpr​ 是为了让第 rrr 行掉下来。 我们考虑按照 pip_ipi​ 从小到大删除每一行，每次删除的时候检查上下两行的颜色是否一致，因为我们是从小到大删除的，所以剩下的行都比当前要删除的行要长。 用模拟链表维护删除行，并查集维护合并行，计算贡献的时候只需要查询当前 iii 行所在的块的大小，第 iii 行可以跟里面任意一行交换，所以 ansansans 直接乘上大小即可，乘完之后大小要减一，因为当前行的贡献已经计算完了。 Code: const int N=2e5+8,mod=998244353;int T=0;int n,ans;int p[N],id[N],c[N],fa[N],siz[N],nxt[N],pre[N];int getfa(int p)&#123;return p==fa[p]?p:fa[p]=getfa(fa[p]);&#125;inline void merge(int u,int v)&#123; u=getfa(u);v=getfa(v); if(siz[u]&lt;siz[v]) swap(u,v); if(u==v) return ; siz[u]+=siz[v]; fa[v]=u;&#125;inline void solve()&#123; read(n);ans=1; for(rint i=1;i&lt;=n;i++) siz[i]=1,nxt[i]=i+1,pre[i]=i-1; for(rint i=1;i&lt;=n;i++) read(p[i]),id[p[i]]=i; for(rint i=1;i&lt;=n;i++) read(c[i]),fa[i]=i; for(rint i=1;i&lt;n;i++) if(c[i]==c[i+1]) merge(i,i+1); for(rint i=1;i&lt;=n;i++)&#123; ans=ans*siz[getfa(id[i])]%mod; siz[getfa(id[i])]--; int pr=pre[id[i]],nx=nxt[id[i]]; nxt[pr]=nx;pre[nx]=pr; if(pr==0||nx==n+1||c[pr]!=c[nx]) continue; merge(nx,pr); &#125; printf(&quot;%lld\\n&quot;,ans);&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://volantis.js.org/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}],"author":"Mr.Az"},{"title":"题解：P10554 [ICPC 2024 Xi'an I] Turn Off The Lights","slug":"题解：P10554 [ICPC 2024 Xi'an I] Turn Off The Lights","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P10554 [ICPC 2024 Xi'an I] Turn Off The Lights/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP10554%20[ICPC%202024%20Xi'an%20I]%20Turn%20Off%20The%20Lights/","excerpt":"","text":"P10554 [ICPC 2024 Xi’an I] Turn Off The Lights 双倍经验：P7315 [COCI 2018/2019 #3] Sajam 两题差别为下表： 差别 P7315 [COCI 2018/2019 #3] Sajam P10554 [ICPC 2024 Xi’an I] Turn Off The Lights 输出方案 不需要 需要 kkk 的范围 k≤nk \\le nk≤n k&lt;nk &lt; nk&lt;n 操作次数 1，21，21，2 操作不限制 ≤3n\\le3n≤3n 快去偷圈！ Algorithm: 神秘观察 + 构造。 Solution: 相信你一定做完了双倍经验，那么这道题多了一些限制，但是这个限制其实并没有用：前两个操作至多操作 nnn 次，第三种操作至多操作 kkk 次，总共至多操作 2n+k&lt;3n2n+k &lt;3n2n+k&lt;3n，所以这个限制没有用。 其他与双倍经验一样，只不过没有 k=nk=nk=n 的情况。 令 aia_iai​ 为第 iii 行的亮灯情况，bib_ibi​ 为第 iii 行熄灯情况，两者互为补集。 对于这道题目，上来是没有头绪的，我们考虑从特殊情况开始思考。 k=0k=0k=0 的情况： 此时不能单独修改特定格子，容易发现存在合法操作方案的条件为每一行亮灯状况与第一行相同或恰好相反，O(N)O(N)O(N) 判断即可。 k&lt;nk &lt; nk&lt;n 的情况： 此时可以修改一些格子，但是由于鸽巢原理，总有一行是没有被修改的。注意到这个之后，我们只需要枚举每一行作为没有被修改的。设当前枚举第 iii 行，仿照 k=0k=0k=0 时候的方法进行判断，将每一行与 aia_iai​ 或 bib_ibi​ 取异或，这样可以找出来他们与第 iii 行不同的位置个数，对 bib_ibi​ 取异或的目的是这一行可以通过题目中的 111 操作进行取反。如果不同的位数 ≤k\\le k≤k 那么存在合法解。 这道题目需要记录下来操作的位置，开个 vector 记录一下即可。 时间复杂度：直接暴力 O(N3)O(N^3)O(N3)，但是我们有 bitset！所以可以优化为 O(N3ω)O(\\frac{N^3}{\\omega})O(ωN3​)。 Code: namespace Mr_Az&#123; int T=1; const int N=1008; int n,k; bitset&lt;N&gt; a[N],t; vector&lt;pii&gt; op; inline void solve()&#123; read(n,k); for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1,x;j&lt;=n;j++)&#123; read(x); a[i][j]=x; &#125; &#125; for(rint i=1;i&lt;=n;i++) t[i]=1; for(rint i=1;i&lt;=n;i++)&#123; int cnt=0; for(rint j=1;j&lt;=n;j++) cnt+=min((a[i]^a[j]).count(),(a[i]^t^a[j]).count()); if(cnt&lt;=k)&#123; for(rint j=1;j&lt;=n;j++) if(a[i][j]==1) op.eb(0,j); for(rint j=1;j&lt;=n;j++)&#123; if((a[i]^a[j]).count()&gt;(a[i]^t^a[j]).count())&#123; a[j]^=t; op.eb(j,0); &#125; for(rint k=1;k&lt;=n;k++) if(a[i][k]!=a[j][k]) op.eb(j,k); &#125; printf(&quot;%u\\n&quot;,op.size()); for(auto [x,y]:op) printf(&quot;%lld %lld\\n&quot;,x,y); return ; &#125; &#125; puts(&quot;-1&quot;); return ; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"bitset","slug":"bitset","permalink":"https://volantis.js.org/tags/bitset/"},{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"}],"author":"Mr.Az"},{"title":"题解：P11452 [USACO24DEC] Cake Game S","slug":"题解：P11452 [USACO24DEC] Cake Game S","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P11452 [USACO24DEC] Cake Game S/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11452%20[USACO24DEC]%20Cake%20Game%20S/","excerpt":"","text":"P11452 [USACO24DEC] Cake Game S Algorithm: 贪心。 Solution: 看上去十分困难的博弈题，实际上是唐氏题。 我们自行模拟会发现，Bessie 最后的蛋糕是一个长度为 n2+1\\frac{n}{2}+12n​+1 区间，但选择这个区间的主动权在 Elsie。也就是说，Bessie 合并的蛋糕是由 Elsie 决定的，所以我们只需要枚举 Elsie 在左边选择了多少个蛋糕并且价值取 max。 Code: int T,n,ans1,ans2;int a[N],sum[N];inline int s(int l,int r)&#123;return sum[r]-sum[l-1];&#125;inline void solve()&#123; read(n); ans1=0; for(rint i=1;i&lt;=n;i++) read(a[i]),sum[i]=sum[i-1]+a[i]; for(rint i=0;i&lt;=n/2-1;i++) ans1=max(ans1,s(1,i)+s(n/2+2+i,n)); printf(&quot;%lld %lld\\n&quot;,s(1,n)-ans1,ans1);&#125;signed main()&#123; read(T); while(T--) solve(); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://volantis.js.org/tags/%E8%B4%AA%E5%BF%83/"},{"name":"博弈","slug":"博弈","permalink":"https://volantis.js.org/tags/%E5%8D%9A%E5%BC%88/"}],"author":"Mr.Az"},{"title":"题解：P11453 [USACO24DEC] Deforestation S","slug":"题解：P11453 [USACO24DEC] Deforestation S","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P11453 [USACO24DEC] Deforestation S/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11453%20[USACO24DEC]%20Deforestation%20S/","excerpt":"","text":"P11453 [USACO24DEC] Deforestation S Algorithm: 贪心。 Solution: 思路有点像 P11232 [CSP-S 2024] 超速检测。 我们将每一个限制按照右端点递增排序后，我们贪心地去选择留下哪些树。很明显留下最右边的一段树是最优的，因为这里的一棵树能贡献到的区间比左边的区间要更多。 所以做法就是将所有区间排序后，贪心地去选择最右边的一段直到满足这一个限制。 细节 为了时间复杂度的正确性，需要二分选择最右边一段的左端点。也可以直接在线段树上二分。 也可以直接用平板电视，每次删除排名在 [rnk⁡(l),rnk⁡(r)][\\operatorname{rnk}(l),\\operatorname{rnk}(r)][rnk(l),rnk(r)] 的数直到满足限制。 绝对不会告诉你直接 for 过去也行。","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://volantis.js.org/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Az"},{"title":"题解：P11454 [USACO24DEC] 2D Conveyer Belt S","slug":"题解：P11454 [USACO24DEC] 2D Conveyer Belt S","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-26T16:00:00.000Z","comments":true,"path":"题解：P11454 [USACO24DEC] 2D Conveyer Belt S/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11454%20[USACO24DEC]%202D%20Conveyer%20Belt%20S/","excerpt":"","text":"P11454 [USACO24DEC] 2D Conveyer Belt S Algorithm: 图论，思维题。 Solution: 我们将边框上能走到外面的点与外面的超级点相连，那么问题转化成哪些点可以走到最外面。于是有了一个最初的想法就是每次把图建出来然后 dfs。这样子时间复杂度是O(N2Q)\\text{O}(N^2Q)O(N2Q)。 正难则反，我们考虑把图建出来后再倒过去删除边计算答案。但是这样子删除一条边会影响很多点，不好处理。我们以把图反过来建，那这样子题目的意思就是从最外面的超级点能走到里面的哪些点。因为是删边，所以合法的点只会越来越多。 所以我们先对整个图 dfs 一遍，把能到的点染色。之后每把一个点变成 ??? 的时候，看他周围有没有之前染过色的点并且自身没有被染色，如果有的话那么从这个点继续 dfs 一遍。因为这个点没有被染色所以说明他之前走不到，他周围有黑色点代表说现在可以走得到这个点了，所以继续从这个点开始 dfs 一遍。 时间复杂度即为 O(N2)\\text{O}(N^2)O(N2)，因为每个点只会被染色一次。 细节 有可能加入边后的点与外面的超级点相连，此时也需要从这个点 dfs 一遍。 ??? 点的连边为从周围四个点分别连边向他自己。 Code: int n,m,ans,res[M];int x[M],y[M],e[N*N][10];vector&lt;int&gt; out;char ch[M],mp[N][N];bool col[N*N];inline bool valid(int x,int y)&#123;return x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=n;&#125;inline int id(int x,int y)&#123; if(!valid(x,y)) return n*n+1;//超级点 return (y-1)*n+x;&#125;inline void add(int x,int y)&#123; if(x==n*n+1)&#123; out.pb(y);//从超级点出发的点 return ; &#125; for(rint i=0;i&lt;10;i++)&#123; if(e[x][i]==y) return ; if(!e[x][i])&#123;e[x][i]=y;break;&#125; &#125; return ;&#125;inline void dfs(int id)&#123; if(col[id]) return ; col[id]=1;ans++; for(rint i=0;i&lt;10;i++) if(e[id][i]) dfs(e[id][i]);&#125;signed main()&#123; read(n,m); for(rint i=1,x,y;i&lt;=m;i++)&#123; read(x,y);cin&gt;&gt;ch[i]; ::x[i]=x;::y[i]=y; switch(ch[i])&#123; case &#x27;L&#x27;:&#123;add(id(x,y-1),id(x,y));break;&#125; case &#x27;R&#x27;:&#123;add(id(x,y+1),id(x,y));break;&#125; case &#x27;U&#x27;:&#123;add(id(x-1,y),id(x,y));break;&#125; case &#x27;D&#x27;:&#123;add(id(x+1,y),id(x,y));break;&#125; &#125; mp[x][y]=ch[i]; &#125; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; int x=i,y=j; if(mp[x][y]) continue; add(id(x-1,y),id(x,y)); add(id(x+1,y),id(x,y)); add(id(x,y-1),id(x,y)); add(id(x,y+1),id(x,y)); //细节2 &#125; &#125; for(auto x:out) dfs(x); out.clear(); res[m]=ans; for(rint i=m;i&gt;1;i--)&#123; int x=::x[i],y=::y[i]; add(id(x-1,y),id(x,y)); add(id(x+1,y),id(x,y)); add(id(x,y-1),id(x,y)); add(id(x,y+1),id(x,y)); //细节2 if((col[id(x-1,y)]||col[id(x,y-1)]||col[id(x+1,y)]||col[id(x,y+1)])) dfs(id(x,y));// 看他周围有没有之前染过色的点并且自身没有被染色 for(auto x:out) dfs(x);// 细节1 out.clear(); res[i-1]=ans; &#125; for(rint i=1;i&lt;=m;i++) printf(&quot;%lld\\n&quot;,n*n-res[i]); return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://volantis.js.org/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"Mr.Az"},{"title":"题解：P11327 [NOISG 2022 Finals] Voting Cities","slug":"题解：P11327 [NOISG 2022 Finals] Voting Cities","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P11327 [NOISG 2022 Finals] Voting Cities/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11327%20[NOISG%202022%20Finals]%20Voting%20Cities/","excerpt":"","text":"P11327 [NOISG 2022 Finals] Voting Cities Algorithm: 分层图最短路。 Solution: 看到 555 张优惠券就笑了，分层最短路的感觉又回来了。 按照使用了多少张优惠券进行分层，记状态 ooo 的第 iii 位二进制位为第 iii 张优惠券的使用情况，跑一边分层图最短路求最小值即可。 分层图最短路是指题目中有 kkk 种操作可以使通过一条路径的代价减少，但是会带来一定的代价，求最后的最短路。对于此，考虑类似 DP 的思想，记 disi,jdis_{i,j}disi,j​ 为从起点到第 iii 个节点，花费的操作状态为 jjj（有些题目可以不用记录状态，记录使用了几次操作）。转移可以写作： disv,op⁡(j)=min⁡(min⁡u→vdisu,j+w,disu,op⁡(j)+op⁡(w))dis_{v,\\operatorname{op}(j)}=\\min(\\min_{u \\to v}dis_{u,j}+w,dis_{u,\\operatorname{op}(j)}+\\operatorname{op}(w)) disv,op(j)​=min(u→vmin​disu,j​+w,disu,op(j)​+op(w)) 其中代表此次操作对状态与边权的改变，www 为这条边的边权。跑一边最短路计算即可。 Code: namespace Mr_Az&#123; const int M=5008,N=M*35; int T=1; int n,m,q,k; int a[N],p[10],dis[N]; bool vis[N]; vector&lt;pii&gt; e[N]; inline int id(int x,int y)&#123;return x*n+y;&#125; inline void dij()&#123; mem(dis,inf);mem(vis,0); priority_queue&lt;pii&gt; q; while(q.size()) q.pop(); for(rint i=1;i&lt;=k;i++) q.push(&#123;0,id(0,a[i])&#125;),dis[id(0,a[i])]=0; while(q.size())&#123; auto [azzzz,u]=q.top();q.pop(); if(vis[u]) continue; vis[u]=1; for(auto [v,w]:e[u])&#123; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(&#123;-dis[v],v&#125;); &#125; &#125; &#125; return ; &#125; inline void solve()&#123; read(n,m,k); for(rint i=1;i&lt;=k;i++) read(a[i]),a[i]++; for(rint i=1,u,v,w;i&lt;=m;i++)&#123; read(u,v,w);u++;v++;swap(u,v); for(rint s=0;s&lt;(1&lt;&lt;5);s++)&#123; e[id(s,u)].eb(id(s,v),w); for(rint j=0;j&lt;5;j++)&#123; if(((s&gt;&gt;j)&amp;1)==0)&#123; e[id(s,u)].eb(id(s+(1&lt;&lt;j),v),w/10*(9-j)); &#125; &#125; &#125; &#125; dij(); read(q); while(q--)&#123; int st,ans=-1,res=0; read(st);for(rint i=0;i&lt;5;i++) read(p[i]); st++; for(rint s=0;s&lt;(1&lt;&lt;5);s++)&#123; res=dis[id(s,st)]; if(res==dis[0]) goto nxt; for(rint i=0;i&lt;5;i++)&#123; if((s&gt;&gt;i)&amp;1)&#123; if(p[i]==-1) goto nxt; res+=p[i]; &#125; &#125; if(ans==-1) ans=res; else ans=min(ans,res); nxt:; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"分层图最短路","slug":"分层图最短路","permalink":"https://volantis.js.org/tags/%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF/"}],"author":"Mr.Az"},{"title":"题解：P11457 [USACO24DEC] Job Completion G","slug":"题解：P11457 [USACO24DEC] Job Completion G","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P11457 [USACO24DEC] Job Completion G/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11457%20[USACO24DEC]%20Job%20Completion%20G/","excerpt":"","text":"P11457 [USACO24DEC] Job Completion G Algorithm: 反悔贪心。 Solution: 如果不会的可以先去做 [JSOI2007] 建筑抢修。 先将所有的工作按照 si+tis_i+t_isi​+ti​从小到大进行排序，那么这道题只需要两种操作，记当前时间为 nownownow： 直接选择这个工作 now≤snow \\le snow≤s，now=t+snow=t+snow=t+s; 无法选择这个工作 now&gt;snow &gt; snow&gt;s，如果之前完成的工作最长用时大于当前任务的 ttt，直接替换掉。 所有完成的工作只需要用大根堆存 ttt。 Code: int T,n; pii a[N];signed main()&#123; read(T); while(T--)&#123; read(n); for(rint i=0;i&lt;n;++i) read(a[i].first,a[i].second); sort(a,a+n,[](pii&amp; a,pii&amp; b)&#123;return (a.first+a.second)&lt;(b.first+b.second);&#125;); priority_queue&lt;int&gt; q; int now=0,cnt=0; for(rint i=0;i&lt;n;i++)&#123; auto [s,t]=a[i]; if(now&lt;=s)&#123; q.push(t); now+=t; cnt++; &#125;//直接选择这工作 else if(!q.empty()&amp;&amp;q.top()&gt;t)&#123; now-=q.top(); q.pop(); q.push(t); now+=t; &#125;//与之前的最长用时工作替换 &#125; cout&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"反悔贪心","slug":"反悔贪心","permalink":"https://volantis.js.org/tags/%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Az"},{"title":"题解：P11526 [THUPC 2025 初赛] Imyourfan","slug":"题解：P11526 [THUPC 2025 初赛] Imyourfan","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P11526 [THUPC 2025 初赛] Imyourfan/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11526%20[THUPC%202025%20%E5%88%9D%E8%B5%9B]%20Imyourfan/","excerpt":"","text":"P11526 [THUPC 2025 初赛] Imyourfan Algorithm: 分类讨论。 Solution: 首先我们会发现 XXX 会把这个字符串分割成若干段，同时我们手玩后还发现每段字符串可以被抽象为以下类型的字符串： m 只有 mmm 的字符串。 w 只有 www 的字符串。 wm 开头结尾分别为 www 和 mmm（顺序不重要）。 wmw 开头结尾为 www，中间出现了 mmm。 mwm 开头结尾为 mmm，中间出现了 www。 这时候就可以贪心选择了，此处只讲 Water 的选择优先级： 有 w 的话就消掉，因为没有影响。 有 wm 的话就消掉，变为 111 个 m。 有 wmw 的话就消掉。 有 mwm 的话就消掉，变为 111 个 m。 Menji 同理。对于 3,43,43,4 的分讨，给一个 hack： 输入：WMWXMWMMXWXMWWM。 输出：Draw。 原因是留着对方夹着自己的，对方要消掉就必须把自己消掉，可能可以达成 Draw，但是我们如果交换 3,43,43,4 则有可能自己留下一个 wmw -&gt; w 导致对方胜利。平局的优先级显然大于失败。 直接模拟就行，最差的时间复杂度也只有 O(∑∣S∣)\\text{O}(\\sum |S|)O(∑∣S∣)。原因是一次操作至少删除掉一个字符。 Code:（分段的代码可能有点丑，但是贪心的部分很清晰） namespace Mr_Az&#123; int T; string s; int m,w,wm,mwm,wmw; inline bool check()&#123; if(!m&amp;&amp;!wm&amp;&amp;!wmw&amp;&amp;!mwm)&#123; if(!w)&#123;puts(&quot;Draw&quot;);return 1;&#125; else&#123;puts(&quot;Menji&quot;);return 1;&#125; &#125; else if(!w&amp;&amp;!wm&amp;&amp;!wmw&amp;&amp;!mwm)&#123;puts(&quot;Water&quot;);return 1;&#125; return 0; &#125; inline void solve()&#123; cin&gt;&gt;s;s+=&#x27;X&#x27;; m=w=wm=mwm=wmw=0; char ch; bool f1=0,f2=0; for(rint i=0,j=0;i&lt;s.size();i++)&#123; if(s[i]==&#x27;X&#x27;) continue; f1=f2=0;ch=s[i];j=i+1; while(j&lt;s.size()&amp;&amp;s[j]!=&#x27;X&#x27;&amp;&amp;s[j+1]!=&#x27;X&#x27;)&#123; if(s[j]==&#x27;W&#x27;) f1=1; if(s[j]==&#x27;M&#x27;) f2=1; j++; &#125; if(s[j]==&#x27;X&#x27;) j--; if(s[i]==&#x27;W&#x27;)&#123; if(s[j]==&#x27;W&#x27;) f2?wmw++:w++; else wm++; &#125; else&#123; if(s[j]==&#x27;M&#x27;) f1?mwm++:m++; else wm++; &#125; i=j+1; &#125; while(1)&#123; if(w) w--; else if(wm) wm--,m++; else if(wmw) wmw--; else if(mwm) mwm--,m++; if(check()) break; if(m) m--; else if(wm) wm--,w++; else if(mwm) mwm--; else if(wmw) wmw--,w++; if(check()) break; &#125; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://volantis.js.org/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"},{"name":"分类讨论","slug":"分类讨论","permalink":"https://volantis.js.org/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"}],"author":"Mr.Az"},{"title":"题解：P11531 [THUPC 2025 初赛] 检查站","slug":"题解：P11531 [THUPC 2025 初赛] 检查站","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P11531 [THUPC 2025 初赛] 检查站/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11531%20[THUPC%202025%20%E5%88%9D%E8%B5%9B]%20%E6%A3%80%E6%9F%A5%E7%AB%99/","excerpt":"","text":"P11531 [THUPC 2025 初赛] 检查站 Algorithm: 网络流（最小割）。 Solution: 为什么我这么*，赛时没切。还有这个 ppp 数组有什么用？其实这道题怎么看都很像网络流，但是在初赛的时候一直在考虑图论做法，没有什么想法。后来去写别的题目就没管了，后悔。 这道题相当于把这个分部控制的边全部断掉，问要断多少个分部才能使 1→n1 \\to n1→n 不连通，显然是一个最小割问题，我们把断一个分部转化为断一条边（点转边），经典的处理手段。所以我们只需要对 (u,v,r)(u,v,r)(u,v,r) 的边处理为：u→rin→rout→vu \\to r_{in} \\to r_{out} \\to vu→rin​→rout​→v。 时间复杂度：O(mm)\\text{O}(m\\sqrt{m})O(mm​)。 Code: int tot=1;int head[M];struct edge&#123;int nxt,to,val;&#125;e[M*2];inline void addd(int u,int v,int w)&#123;e[++tot]=&#123;head[u],v,w&#125;;head[u]=tot;&#125;inline void add(int u,int v,int w)&#123;addd(u,v,w);addd(v,u,0);&#125;namespace dinic&#123; int s,t,maxflow,flow; int h[M],dep[M]; inline bool bfs()&#123; mem(dep,0); queue&lt;int&gt; q; q.push(s);h[s]=head[s];dep[s]=1; while(q.size())&#123; auto u=q.front();q.pop(); for(rint i=head[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(e[i].val&amp;&amp;(!dep[v]))&#123; dep[v]=dep[u]+1; q.push(v); h[v]=head[v]; if(v==t) return 1; &#125; &#125; &#125; return 0; &#125; inline int dfs(int u,int flow)&#123; if(u==t) return flow; int now=flow; for(rint i=h[u];i&amp;&amp;now;i=e[i].nxt)&#123; int v=e[i].to; h[u]=i; if(e[i].val&amp;&amp;dep[v]==dep[u]+1)&#123; int k=dfs(v,min(now,e[i].val)); if(!k) dep[v]=0; now-=k; e[i].val-=k; e[i^1].val+=k; &#125; &#125; return flow-now; &#125; inline int dinic(int S,int T)&#123; s=S;t=T; maxflow=flow=0; while(bfs()) while(flow=dfs(s,INF)) maxflow+=flow; return maxflow; &#125;&#125;// dinic 板子，要的可以拿走，目前使用下来没有任何问题namespace Mr_Az&#123; int T=1; int n,m,c,s,t; int p[N]; inline int id(int i,int o)&#123;return n+1+2*(i-1)+o;&#125; inline void solve()&#123; read(n,m,c); s=1;t=n; for(rint i=1;i&lt;=c;i++) read(p[i]); for(rint i=1;i&lt;=c;i++) add(id(i,0),id(i,1),1);// r_in -&gt; r_out for(rint i=1,u,v,r;i&lt;=m;i++)&#123; read(u,v,r); add(u,id(r,0),inf);// u -&gt; r_in add(id(r,1),v,inf);// r_out -&gt; v &#125; auto maxflow=dinic::dinic(s,t); printf(&quot;%lld\\n&quot;,maxflow); &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://volantis.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"}],"author":"Mr.Az"},{"title":"题解：P11744 Dynamic TSP Problem","slug":"题解：P11744 Dynamic TSP Problem","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P11744 Dynamic TSP Problem/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP11744%20Dynamic%20TSP%20Problem/","excerpt":"","text":"P11744 Dynamic TSP Problem Algorithm: 二分。 好像爆标了？ Solution: 观察到答案具有单调性（你带的钱越多获利的次数越多剩的钱也越多），因此考虑二分答案。 考虑最显然的 O(nmlog⁡V)\\text{O}(nm\\log V)O(nmlogV)，遍历每一条路径判断合法性。 观察到 nnn 和 mmm 的大小差距十分的大，所以 mmm 条路径有许多是重复遍历到的。因此我们可以考虑把每一条路径拿 vector 存下来，每次 check 只需要从 nnn 个点出发，记录起点，当前资金，获利次数，每次走到一个点 uuu 就查询所有起点到 uuu 的路径，检查合法性。 每次 check 时间复杂度 O(n2)\\text{O}(n^2)O(n2)，总的时间复杂度 O(n2log⁡V)\\text{O}(n^2\\log V)O(n2logV)。 Code: namespace Mr_Az&#123; const int N=508,M=2e5+8; int T=1; int n,m; vector&lt;int&gt; e[N]; struct city&#123;int a,b,c;&#125;a[N]; struct ask&#123;int y,k;&#125;; vector&lt;ask&gt; journey[N][N]; inline bool dfs(int u,int fa,int st,int x,int hl)&#123; if(x&gt;=a[u].a) x+=a[u].b,hl++; else x-=a[u].c; if(journey[st][u].size()) for(auto [c,d]:journey[st][u]) if(x&lt;c||hl&lt;d) return 0; for(auto v:e[u]) if(v!=fa) if(!dfs(v,u,st,x,hl)) return 0; return 1; &#125;// u: 当前节点 st: 起点 x: 当前资金 hl: 获利次数 inline bool check(int x)&#123; for(rint i=1;i&lt;=n;i++) if(!dfs(i,0,i,x,0)) return 0; return 1; &#125; inline void solve()&#123; read(n,m); for(rint i=1,u,v;i&lt;n;i++) read(u,v),e[u].pb(v),e[v].pb(u); for(rint i=1,A,B,C;i&lt;=n;i++) read(A,B,C),a[i]=&#123;A,B,C&#125;; for(rint i=1,A,B,C,D;i&lt;=m;i++) read(A,B,C,D),journey[A][B].pb(&#123;C,D&#125;); // 由于 n 只有 500，所以直接开个 vector 把所有的旅行记录下来 int l=0,r=INF,ans=0; while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(check(mid)) r=mid; else l=mid+1; &#125;// 二分答案 printf(&quot;%lld\\n&quot;,l); &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://volantis.js.org/tags/%E4%BA%8C%E5%88%86/"},{"name":"离线处理","slug":"离线处理","permalink":"https://volantis.js.org/tags/%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86/"}],"author":"Mr.Az"},{"title":"题解：P12015 [NOISG 2025 Finals] 怪物","slug":"题解：P12015 [NOISG 2025 Finals] 怪物","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12015 [NOISG 2025 Finals] 怪物/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12015%20[NOISG%202025%20Finals]%20%E6%80%AA%E7%89%A9/","excerpt":"","text":"P12015 [NOISG 2025 Finals] Monsters Algorithm: 贪心。 Solution: 场上写了一个小时，无脸见人。 首先炸弹肯定在移动完怪兽后才引爆，我们也不会增加怪物血量。 所以我们把所有的怪物分为两部分，一部分是直接被扣光血量的，一部分是被炸弹炸死。记 did_idi​ 为第 iii 只怪兽距离最近的炸弹的距离，那么有： hi≤dih_i \\le d_ihi​≤di​：直接扣光，代价 +di+d_i+di​。 hi&gt;dih_i&gt;d_ihi​&gt;di​：走到炸弹上，代价 +hi+h_i+hi​。 但是我们需要对第二种情况进行讨论，因为可能怪兽距离前后的炸弹距离一致，那么我们只要按以下贪心策略选择即可，记 preprepre 为前一个炸弹的编号，nxtnxtnxt 为后一个炸弹的编号，fif_ifi​ 为这个编号上的炸弹有没有被选择。 将所有的怪物按照坐标进行排序。 如果 fpre=1f_{pre}=1fpre​=1，则不需要操作，直接走到前一个炸弹位置即可。 如果 fpre=0f_{pre}=0fpre​=0，则选择走到后一个炸弹，让 fnxt=1f_{nxt}=1fnxt​=1，代价 +1+1+1。 正确性显然，二分查找前后炸弹。 代码很丑，别看了。 Code: namespace Mr_Az&#123; int T=1; const int N=2e5+8; int n,k,ans; int x[N]; bool f[N]; struct node&#123; int a,h; bool operator&lt;(const node &amp;A)const&#123;return a&lt;A.a;&#125; &#125;a[N]; inline void solve()&#123; read(n,k); f[0]=1; for(rint i=1;i&lt;=n;i++) read(a[i].a,a[i].h); for(rint i=1;i&lt;=k;i++) read(x[i]); sort(a+1,a+n+1);sort(x+1,x+k+1); for(rint i=1;i&lt;=n;i++)&#123; int nxt=upper_bound(x+1,x+k+1,a[i].a)-x,pre=nxt-1; int pr=a[i].a-x[pre],nx=x[nxt]-a[i].a; if(pre==0) pre=0,pr=INF; if(x[nxt]&lt;a[i].a) nxt=0,nx=INF; if(a[i].h&lt;=min(pr,nx)) ans+=a[i].h; else&#123; ans+=min(pr,nx); if(pr&lt;nx)&#123;if(!f[pre]) f[pre]=1,ans++;&#125; else if(pr&gt;nx)&#123;if(!f[nxt]) f[nxt]=1,ans++;&#125; else&#123; if(!f[pre]&amp;&amp;!f[nxt]) f[nxt]=1,ans++; &#125; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://volantis.js.org/tags/%E8%B4%AA%E5%BF%83/"}],"author":"Mr.Az"},{"title":"题解：P12017 [NOISG 2025 Finals] 可达性","slug":"题解：P12017 [NOISG 2025 Finals] 可达性","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12017 [NOISG 2025 Finals] 可达性/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12017%20[NOISG%202025%20Finals]%20%E5%8F%AF%E8%BE%BE%E6%80%A7/","excerpt":"","text":"P12017 [NOISG 2025 Finals] Reachability Algorithm: 树形背包。 Solution: 被薄纱了。 看到这道题让我会想到了省选的岁月，但其实两道题目并没有任何相似之处。 观察到 u→vu \\rightarrow vu→v 的边相当于让 uuu 能够到达的点加上 vvv 能够到的点的数量。这能够让我们发现两点之间可能的边的限制。具体而言如下所示： 当 lu=lvl_u=l_vlu​=lv​ 时，u,vu,vu,v 之间的边要么为双向边或者没有连边，原因是若为单向边则两个点能够到达点的数量至少差 111。 当 lu≠lvl_u \\neq l_vlu​=lv​ 是，u,vu,vu,v 之间的便要么为单向边（lll 值大的点连向 lll 值小的点）或者没有连边。 加上之前的观察，不难发现是一个树上背包的形式。所以考虑设 fu,if_{u,i}fu,i​ 代表在计算到 uuu 的时候，uuu 能够到达的点数量为 iii 是否合法。转移只要按照上面的分类讨论一下即可，具体而言如下所示：（sizisiz_isizi​ 为 iii 这个点的子树大小） 当 lu=lvl_u=l_vlu​=lv​ 时： u↔vu \\leftrightarrow vu↔v： fu,i+j∣=fu,i&amp;fv,j(i∈[0,sizu],j∈[0,sizv])f_{u,i+j}|=f_{u,i}\\&amp;f_{v,j}(i \\in [0,siz_u],j \\in [0,siz_v])fu,i+j​∣=fu,i​&amp;fv,j​(i∈[0,sizu​],j∈[0,sizv​])。 u↛vu \\not \\rightarrow vu→v：此时必须满足 fv,lv=1f_{v,l_v}=1fv,lv​​=1。 当 lu&gt;lvl_u &gt; l_vlu​&gt;lv​ 时： u→vu \\rightarrow vu→v： fu,i+lv∣=fu,i(i∈[0,sizu])f_{u,i+l_v}|=f_{u,i}(i \\in [0,siz_u])fu,i+lv​​∣=fu,i​(i∈[0,sizu​])。 u↛vu \\not \\rightarrow vu→v：此时必须满足 fv,lv=1f_{v,l_v}=1fv,lv​​=1。 当 lu&lt;lvl_u&lt;l_vlu​&lt;lv​ 时： u←vu \\leftarrow vu←v：此时必须满足 fv,lv−lu=1f_{v,l_v-l_u}=1fv,lv​−lu​​=1。 u↛vu \\not \\rightarrow vu→v：此时必须满足 fv,lv=1f_{v,l_v}=1fv,lv​​=1。 不满足的情况可以直接输出 NO 退出。最后检查根节点是否合法即可。在实际实现的过程中会遇到 fu,if_{u,i}fu,i​ 在一个儿子被更新后去更新其他状态，所以需要辅助数组 gig_igi​ 用来暂时存储 fu,if_{u,i}fu,i​ 的状态，更新完后重新赋值。 Code: namespace Mr_Az&#123; const int N=5008; int T=1; int n; int l[N],siz[N]; bool f[N][2*N],g[2*N]; vector&lt;int&gt; e[N]; void dfs(int u,int fa)&#123; siz[u]=1; for(auto v:e[u])&#123; if(v==fa) continue; dfs(v,u); if(l[u]==l[v])&#123;// 所达城市数量一致 // 1. 连边 for(rint i=0;i&lt;=siz[u];i++) for(rint j=0;j&lt;=siz[v];j++) g[i+j]|=(f[u][i]&amp;f[v][j]); // 2. 断开(下面必须要满足要求) if(f[v][l[v]])&#123; for(rint i=0;i&lt;=siz[u];i++) g[i]|=f[u][i]; &#125; &#125; else&#123;// 所达城市数量不一致 if(l[u]&gt;l[v])&#123;// 1. u-&gt;v 或不连边 if(!f[v][l[v]])&#123;puts(&quot;NO&quot;);exit(0);&#125; else&#123; for(rint i=0;i&lt;=siz[u];i++)&#123; g[i+l[v]]|=f[u][i]; g[i]|=f[u][i]; &#125; &#125; &#125; else&#123;// 2. v-&gt;u 或不连边 if(!f[v][l[v]]&amp;&amp;!f[v][l[v]-l[u]])&#123;puts(&quot;NO&quot;);exit(0);&#125; for(rint i=0;i&lt;=siz[u];i++) g[i]|=f[u][i]; &#125; &#125; siz[u]+=siz[v]; for(rint i=0;i&lt;=siz[u];i++) f[u][i]=g[i]; mem(g,0); &#125; &#125; inline void solve()&#123; read(n); for(rint i=1;i&lt;=n;i++) read(l[i]); for(rint i=1,u,v;i&lt;n;i++)&#123; read(u,v); e[u].pb(v);e[v].pb(u); &#125; for(rint i=1;i&lt;=n;i++) f[i][1]=1; dfs(1,0); if(f[1][l[1]]) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"树形 DP","slug":"树形-dp","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2-dp/"},{"name":"树形背包","slug":"树形背包","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/"}],"author":"Mr.Az"},{"title":"题解：P12195 [NOISG 2025 Prelim] Itinerary","slug":"题解：P12195 [NOISG 2025 Prelim] Itinerary","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12195 [NOISG 2025 Prelim] Itinerary/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12195%20[NOISG%202025%20Prelim]%20Itinerary/","excerpt":"","text":"P12195 [NOISG 2025 Prelim] Itinerary Algorithm: 树链剖分。 Solution: 赛时没切，大悲。 由于树的性质：从 uuu 到 vvv 的任意路径至少要经过其两点间最短路一次，加上我们遍历到的活动城市是要按顺序遍历的，所以我们可以猜测一个行程不合法的情况当且仅当沿着行程中相邻两点的最短路遍历的时候至少一条边被遍历了大于 222 次。 这个结论显然是正确的，因为其他在这个遍历顺序中没有遍历到的边都可以进去走一遍再出来，对结果并没有影响。 于是我们要做的就是维护路径加，全局最小值，树链剖分即可。 我们首先按顺序将活动行程中相邻两点的最短路加入，至于从不同城市出发，在活动行程的最开始加入 iii 到 s1s_1s1​ 的最短路判断最小值是否 ≤2\\le 2≤2 即可。 赛事没切的原因是忘记树链剖分的细节了，自己的实现出现了问题。 时间复杂度：O(nlog⁡2n)\\text{O}(n \\log^2 n)O(nlog2n)。 提供另外一个做法，发现这道题要做的就是将每一个城市作为活动行程的起点时，活动行程是否是以这个城市开头的欧拉序列的子序列。 所以可以直接换根 DP，但是笔者没有实现。 Code: void read(T &amp;x, Args &amp;... y)&#123;read(x);read(y...);&#125;int n,m,ddfn;int s[N],dfn[N],ed[N],siz[N],son[N],top[N],dep[N],fa[N];vector&lt;int&gt; e[N];void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1;siz[u]=1;::fa[u]=fa; int mx=0; for(auto v:e[u])&#123; if(v==fa) continue; dfs(v,u); if(mx&lt;siz[v]) son[u]=v,mx=siz[v]; siz[u]+=siz[v]; &#125; return ;&#125;void dfs1(int u,int fa,int t)&#123; top[u]=t;dfn[u]=++ddfn; if(!son[u]) return ; dfs1(son[u],u,t); for(auto v:e[u])&#123; if(v!=fa&amp;&amp;v!=son[u]) dfs1(v,u,v); &#125; // ed[u]=ddfn; return ;&#125;inline bool in(int x,int y)&#123;return dfn[y]&lt;=dfn[x]&amp;&amp;dfn[x]&lt;=ed[y];&#125;struct tree&#123; int x,add; #define x(p) t[p].x #define add(p) t[p].add&#125;t[N*4];#define mid (l+r&gt;&gt;1)inline void update(int p)&#123;x(p)=max(x(ls),x(rs));&#125;inline void spread(int p)&#123; if(add(p)!=0)&#123; x(ls)+=add(p); x(rs)+=add(p); add(ls)+=add(p);add(rs)+=add(p); add(p)=0; &#125; return ;&#125;void addd(int p,int l,int r,int L,int R,int k)&#123; if(L&gt;R) return ; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;x(p)+=k;add(p)+=k;return ;&#125; spread(p); if(L&lt;=mid) addd(ls,l,mid,L,R,k); if(R&gt;mid) addd(rs,mid+1,r,L,R,k); update(p); return ;&#125;int ask(int p,int l,int r,int L,int R)&#123; if(L&gt;R) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return x(p); spread(p); int res=0; if(L&lt;=mid) res=max(res,ask(ls,l,mid,L,R)); if(R&gt;mid) res=max(res,ask(rs,mid+1,r,L,R)); update(p); return res;&#125;#undef x#undef mid#undef addinline bool add(int x,int y,int k)&#123; bool res=1; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swap(x,y); addd(1,1,n,dfn[top[x]],dfn[x],k); if(ask(1,1,n,1,n)&gt;=3) res=0; x=fa[top[x]]; &#125; if(dep[x]&gt;dep[y]) swap(x,y); if(x!=y)&#123; addd(1,1,n,dfn[x]+1,dfn[y],k); if(ask(1,1,n,1,n)&gt;=3) res=0; &#125; return res;&#125;signed main()&#123; int st=clock(); read(n,m); for(rint i=1,u,v;i&lt;n;i++) read(u,v),e[u].pb(v),e[v].pb(u); dfs(1,0);ddfn=0; dfs1(1,0,1); for(rint i=1;i&lt;=m;i++) read(s[i]); for(rint i=2;i&lt;=m;i++)&#123; bool f=add(s[i-1],s[i],1); if(!f)&#123;for(rint i=1;i&lt;=n;i++) puts(&quot;0&quot;);return 0;&#125; &#125; for(rint i=1;i&lt;=n;i++)&#123; if(i==s[1]) puts(&quot;1&quot;); else&#123; bool f=add(i,s[1],1); puts(f?&quot;1&quot;:&quot;0&quot;); add(i,s[1],-1); &#125; &#125; return 0;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://volantis.js.org/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}],"author":"Mr.Az"},{"title":"题解：P1226 【模板】快速幂","slug":"题解：P1226 【模板】快速幂","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P1226 【模板】快速幂/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP1226%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"P1226 【模板】快速幂 Solution: 1. 暴力解法，时间复杂度 O(n)\\text{O}(n)O(n) 原理： 先考虑最暴力的方法，直接 for 一遍求解，时间复杂度 O(n)\\text{O}(n)O(n)。 代码： int res=1;for(int i=1;i&lt;=b;i++) res=（res*a)%mod; 弊端： 但是这样子在多次调用的时候复杂度过高，不可以接受。 2. 快速幂，时间复杂度 O(log⁡n)\\text{O}(\\log n)O(logn) 原理： 在讲解快速幂前，我们需要知道基本的幂的运算法则：ab×ac=ab+ca^b \\times a^c = a^{b+c}ab×ac=ab+c。 我们发现一次一次的乘太慢了，能不能直接乘上一个 axa^xax ，这样子乘一次就相当于我们原来乘 xxx 次。所以我们可以考虑将 bbb 进行二进制拆位，也就是拆成形如 b=∑pi2ib=\\sum p_i2^ib=∑pi​2i 的样子。这样子我们要求的就相当于： (ab)=a∑pi×2i=ap0×20×ap1×21×...×apm×2m(a^b)=a^{\\sum p_i \\times 2^i}=a^{p_0 \\times 2^0} \\times a^{p_1 \\times 2^1}\\times ...\\times a^{p_m \\times 2^m} (ab)=a∑pi​×2i=ap0​×20×ap1​×21×...×apm​×2m 为什么要二进制拆位呢？因为我们可以很方便求出 a2ia^{2^i}a2i，每次只要让 a2i−1a^{2^{i-1}}a2i−1 自己乘上自己就可以求出来了。 所以，快速幂的精髓就在于将 bbb 二进制拆位拆出 pip_ipi​ 序列，然后再让 aaa 不断乘上自己，进行求和。a2ia^{2^i}a2i 是好处理的，但是怎么才能快速求出 pip_ipi​ 序列呢？ 在这里我们可以用到位运算，b&amp;1 可以求出 bbb 在二进制下最后一位是 000 还是 111，而 b&gt;&gt;1 可以让 bbb 右移一位，这样子原来的第二位就会变成最后一位。于是我们便可以通过这种方式同时求出 pip_ipi​ 和 a2ia^{2^i}a2i 了。 时间复杂度，每一位遍历一次，所以是 O(log⁡n)\\text{O}(\\log n)O(logn)，这个复杂度十分的小。 代码： 在一般的实现中，我们不会直接计算出 pip_ipi​，而是想上面说的通过每次右移和取最后一位来达到求第 iii 位的值。 int power(int a,int b)&#123; int res=1; // 注意不要初始化为 0 while(b)&#123; // 遍历 b 的每一个二进制位 if(b&amp;1) res=(res*a)%mod;// 如果第 i 位是1，那么答案就乘上 a^&#123;2^i&#125; a=a*a%mod; // 计算 a^&#123;2^i&#125; b&gt;&gt;=1; // 让 b 右移一位，开始计算下一位 &#125; return res;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://volantis.js.org/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"Mr.Az"},{"title":"题解：P12444 [COTS 2025] 发好奖  Hijerarhija","slug":"题解：P12444 [COTS 2025] 发好奖  Hijerarhija","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12444 [COTS 2025] 发好奖  Hijerarhija/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12444%20[COTS%202025]%20%E5%8F%91%E5%A5%BD%E5%A5%96%20%20Hijerarhija/","excerpt":"","text":"P12444 [COTS 2025] 发好奖 / Hijerarhija Algorithm: 树形背包。 Solution: O(N3)\\text{O}(N^3)O(N3) 的树形背包是好想的，我们令 fu,vf_{u,v}fu,v​ 为第 uuu 个点花费 vvv 的代价得到的最大收益，但是比较难优化。 在写转移的时候可以感觉到在数据没有刻意构造的情况下，合法的状态不是很多。所以考虑将每个点的合法状态拿个 vector 存起来转移，同时如果存在 i&lt;ji&lt;ji&lt;j 并且 fu,i≥fu,jf_{u,i}\\ge f_{u,j}fu,i​≥fu,j​ 的情况下，可以把 fu,jf_{u,j}fu,j​ 情况排除掉因为显然不优。 Code: namespace Mr_Az&#123; const int N=5008; int T=1; int n,k,res,cnt; int p[N],c[N],g[N][N],f[N][N],siz[N]; vector&lt;int&gt; s[N],e[N]; void dfs(int u,int fa)&#123; siz[u]=c[u]; f[u][c[u]]=p[u]; if(c[u]!=1) f[u][1]=0; for(auto v:e[u])&#123; if(v==fa) continue; dfs(v,u); for(rint i=0;i&lt;=min(siz[u],k);i++) g[u][i]=f[u][i]; for(rint i=0;i&lt;=min(siz[u],k);i++)&#123; if(g[u][i]&lt;0) continue; for(auto j:s[v])&#123; if(i+j&gt;k) break; f[u][i+j]=max(f[u][i+j],f[v][j]+g[u][i]); &#125; &#125; siz[u]+=siz[v]; &#125; int mx=0; for(rint i=0;i&lt;=min(siz[u],k);i++) if(f[u][i]&gt;mx) s[u].eb(i),mx=f[u][i]; return ; &#125; inline void solve()&#123; read(n,k);mem(f,-inf); for(rint i=2,x;i&lt;=n;i++) read(x),e[i].pb(x),e[x].pb(i); for(rint i=1;i&lt;=n;i++) read(p[i]); for(rint i=1;i&lt;=n;i++) read(c[i]); dfs(1,0); int ans=0; for(rint i=0;i&lt;=k;i++)&#123; ans=max(&#123;ans,f[1][i]&#125;); &#125; printf(&quot;%d\\n&quot;,ans); return ; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"树形 DP","slug":"树形-dp","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2-dp/"},{"name":"树形背包","slug":"树形背包","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/"}],"author":"Mr.Az"},{"title":"题解：P12449 [COTS 2025] 吸尘  Usisavač","slug":"题解：P12449 [COTS 2025] 吸尘  Usisavac","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12449 [COTS 2025] 吸尘  Usisavac/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12449%20[COTS%202025]%20%E5%90%B8%E5%B0%98%20%20Usisavac/","excerpt":"","text":"[COTS 2025] 吸尘 / Usisavač Algorithm: 构造 + 模拟。 Solution: 一般这种题目思考方式可以是从链上的做法扩展到树上（但这道题比较困难），所以笔者先考虑了链上的特殊情况。 Subtask 2（10 pts）: 可以按照以下方法进行贪心： 此处 nnn 代表边数，即 n←n−1n \\leftarrow n-1n←n−1。 如果 r≥nr \\ge nr≥n，那么直接输出 nnn。 将长度为 nnn 的路径分成若干个长度不超过 rrr 的子段，若最后剩余部分长度不足 rrr，则单独作为一段处理。 将最后一段长度为 rrr 的段与剩余段交换顺序，然后按如图所示方法清扫（橙色代表手上吸尘器插入，黑色代表手上吸尘器没有插入）： 经过计算（令 n mod x≡mn \\bmod x \\equiv mnmodx≡m），答案应为：3×(x(⌊nx⌋−1)+m)+x=3n−2x3 \\times (x(\\lfloor \\frac{n}{x} \\rfloor -1)+m)+x=3n-2x3×(x(⌊xn​⌋−1)+m)+x=3n−2x。 while(m--)&#123; int x;read(x); if(x&gt;=n) printf(&quot;%lld &quot;,n) else printf(&quot;%lld &quot;,3*n-2*x);&#125; 本质上我们需要走完整条路径 nnn 的三倍长度，但最后一段只需走一遍，无需返回，因而可省下 2x2x2x，总共 3n−2x3n - 2x3n−2x。 正解： 但是在树上的时候，我们发现链上的情况比较难以扩展。所以我们推翻前面的过程，直接考虑树的做法。经过手玩我们会发现一些性质： 最终结束的位置一定是一个深度最大的点，从 111 到该点的最短路上的边可以少走一次（在这里结束就不需要返回到根去扫另一棵子树了）； 加上从 111 到结束点最短路上的边后，每条边要么经过两次，要么经过四次； 经过两次的边一定为某些子树。 以下讨论边经过的次数默认加上从 111 到结束点最短路上的边。 类比 Subtask 2 中对最后一段的处理，树上对应的做法是：在靠近叶子的某个点插入电源，并恰好能够扫完它的整棵子树。 形式化地说，记 mximx_imxi​ 为 max⁡v∈subtreeudepv−depu+1\\max_{v \\in subtree_u} dep_v-dep_u+1maxv∈subtreeu​​depv​−depu​+1，也就是子树中最深的点为根时，这个点的深度。那么上面那句话的这个点要满足 mxu≤rmx_u \\le rmxu​≤r 并且 mxfau&gt;rmx_{fa_u} &gt; rmxfau​​&gt;r。我们把这样的点提出来之后会发现：这些点子树里的边都只经过两次。 （请读者在这里思考：为什么条件是 mxu≤rmx_u \\le rmxu​≤r 并且 mxfau&gt;rmx_{fa_u} &gt; rmxfau​​&gt;r。） 对于这个发现，证明非常好想，我们考虑每一次经过这条边都在干啥： 边类型 情况 次数 原因 关键点子树内边 子树可独立清扫 2 次 插吸尘器清扫 + 返回 非关键点子树边 需递归清扫其剩余子树 4 次 插吸尘器清扫 + 返回拿吸尘器 + 下去子树里清扫 + 返回 如何证明这是最优的方案，我们称插入电源的点记为关键点，那么则有： 若这个点的子树内没有关键点，则至少要走两次，对应上方子树里的边经过两次； 若这个点的子树内有关键点，则至少要走四次，对应上方非子树里的边经过四次； 由此可见，我们想让该方案最优必须要让 222 情况覆盖的边数更多，而对于 mxu&gt;rmx_u &gt; rmxu​&gt;r 的点，其内部必然存在至少一个关键点，因为只凭这个点无法扫到其的所有子树。所以最优的方案就是将所有 mxu≤rmx_u \\le rmxu​≤r 并且 mxfau&gt;rmx_{fa_u} &gt; rmxfau​​&gt;r 的点全部选择。 至于统计答案，可以直接 dfs 预处理答案，也可以观察到对于任意一条父子边 (u,son)(u,son)(u,son)，如果 mxu≤rmx_u \\le rmxu​≤r，那么这条边走两次，反之走四次，证明显然。 记 cnticnt_icnti​ 为 mxu=imx_u=imxu​=i 的点的数量，那么答案即为：4(n−1)−max⁡{depu}−2∑i=1rcnti4(n-1)-\\max\\{dep_u\\}-2\\sum_{i=1}^{r} cnt_i4(n−1)−max{depu​}−2∑i=1r​cnti​，给 cnt 数组做个前缀和即可。 需要注意，cntmx1cnt_{mx_1}cntmx1​​ 需要减一，不然会少算。 这道题目的关键在于发现深度最大路径可以少走一次以及关键点如何选择以减少遍历次数。 Code: namespace Mr_Az&#123; const int N=3e5+8; int T=1; int n,m,MAX; int deg[N],dep[N],cnt[N],mx[N]; bool spj1=1; vector&lt;int&gt; e[N]; void dfs(int u,int fa)&#123; dep[u]=dep[fa]+1;MAX=max(MAX,dep[u]-1); if(e[u].size()==1) mx[u]=1; for(auto v:e[u])&#123; if(v==fa) continue; dfs(v,u); mx[u]=max(mx[u],mx[v]+1); &#125; cnt[mx[u]]++; return ; &#125; inline void solve()&#123; read(n,m); for(rint i=1,u,v;i&lt;n;i++)&#123; read(u,v),e[u].pb(v),e[v].pb(u); deg[u]++;deg[v]++; spj1&amp;=(deg[u]&lt;=2&amp;&amp;deg[v]&lt;=2); &#125; if(spj1)&#123; n--; while(m--)&#123; int x;read(x); printf(&quot;%lld &quot;,3*n-2*x); &#125; return ; &#125;// 可删去，链情况特判。 dfs(1,0); cnt[mx[1]]--; // 小细节 for(rint i=1;i&lt;=n;i++) cnt[i]+=cnt[i-1]; while(m--)&#123; int x;read(x); printf(&quot;%lld &quot;,4*(n-1)-MAX-2*cnt[x]); &#125; return ; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125; 样例解释 下面为样例二的手玩结果：","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://volantis.js.org/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"}],"author":"Mr.Az"},{"title":"题解：P12501 「ROI 2025 Day1」奥林匹克楼梯","slug":"题解：P12501 「ROI 2025 Day1」奥林匹克楼梯","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12501 「ROI 2025 Day1」奥林匹克楼梯/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12501%20%E3%80%8CROI%202025%20Day1%E3%80%8D%E5%A5%A5%E6%9E%97%E5%8C%B9%E5%85%8B%E6%A5%BC%E6%A2%AF/","excerpt":"","text":"P12501 「ROI 2025 Day1」奥林匹克楼梯 Algorithm: 单调栈。 Solution: 本人赛时想麻烦了，先讲正解。 正解： 以下讨论定义长度为固定列 jjj 时，第 iii 行的 nxti,jnxt_{i,j}nxti,j​。后缀的意思为从下到上。 我们可以先 O(hw)\\text{O}(hw)O(hw) 预处理出一个数组 nxtx,ynxt_{x,y}nxtx,y​ 表示 (x,y)(x,y)(x,y) 的这个点往右边多少格都为 111。转移是显然的。特别的，如果 (x,y)(x,y)(x,y) 为 000，那么 nxtx,y=0nxt_{x,y}=0nxtx,y​=0。那题目所求的内容就变为 ∑i=yn(min⁡j=iynxtx,j)\\displaystyle \\sum_{i=y}^{n} (\\min_{j=i}^{y} nxt_{x,j})i=y∑n​(j=iminy​nxtx,j​)。 暴力计算即为每次枚举一个点 (x,y)(x,y)(x,y)，计算上面的式子。对于每个点的答案取 max⁡\\maxmax 即为最后答案，时间复杂度为 O(h2w)\\text{O}(h^2w)O(h2w)。 考虑如何优化，发现这个形式很符合单调栈的形式，因为最后的形状一定是单调递增的，其中突出的部分会和下面行中最短的取 min⁡\\minmin。所以每一行的长度即为后缀最小值。用单调栈维护后缀最小值的位置，计算当前行的长度能贡献到的地方，用 fif_ifi​ 存一下第 iii 行的时候的答案转移即可。时间复杂度为 O(hw)\\text{O}(hw)O(hw)。 Code: namespace Mr_Az&#123; const int N=4e6+8; int T=1; int n,m,ans; int nxt[N],f[N]; bool a[N]; inline int id(int x,int y)&#123;return (x-1)*m+y;&#125; inline void solve()&#123; read(n,m); for(rint i=1;i&lt;=n;i++) for(rint j=1;j&lt;=m;j++)&#123; char ch;scanf(&quot; %c&quot;,&amp;ch); a[id(i,j)]=ch-&#x27;0&#x27;; &#125; for(rint i=1;i&lt;=n;i++)&#123; for(rint j=m;j&gt;=1;j--)&#123; if(a[id(i,j)])&#123; if(j==m) nxt[id(i,j)]=1; else nxt[id(i,j)]=nxt[id(i,j+1)]+1; &#125; &#125; &#125; for(rint j=1;j&lt;=m;j++)&#123; stack&lt;int&gt; st; while(st.size()) st.pop(); for(rint i=1;i&lt;=n;i++)&#123; while(st.size())&#123; if(nxt[id(i,j)]&lt;=nxt[id(st.top(),j)]) st.pop(); else break; &#125;// 维护后缀最小值。 if(st.size()) f[i]=f[st.top()]+(i-st.top())*nxt[id(i,j)];// 如果这一行不是最短的，那么可以从前面的位置加上一个矩形。 else f[i]=i*nxt[id(i,j)];// 如果这一行是最短的，那么此时楼梯就是一个矩形。 st.push(i); ans=max(ans,f[i]); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125; 赛时做法：（读者可以直接跳过） 扯完了正解，讲一下赛时的做法。 我们发现加入一行相当于对前面行的长度全部取 min⁡\\minmin，一个暴力的想法是直接建立权值线段树硬做，实现区间求和，区间覆盖，单点加即可，但是卡不过去。时间复杂度 O(hwlog⁡w)\\text{O}(hw \\log w)O(hwlogw)。 后面去写单调栈了。","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://volantis.js.org/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}],"author":"Mr.Az"},{"title":"题解：P12505 「ROI 2025 Day2」充实的假期","slug":"题解：P12505 「ROI 2025 Day2」充实的假期","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P12505 「ROI 2025 Day2」充实的假期/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP12505%20%E3%80%8CROI%202025%20Day2%E3%80%8D%E5%85%85%E5%AE%9E%E7%9A%84%E5%81%87%E6%9C%9F/","excerpt":"","text":"P12505 「ROI 2025 Day2」充实的假期 Algorithm: 分类讨论。 Solution: 如果你觉得不太可做，说明你可能读错了题目。注意到：题目要求的是有几个充实休假日而不是最长的充实休假日。 我们手玩一下样例可以发现以下性质： 01010 型：此时将中间的 000 变为 111 可以获得 333 的贡献。 010 型：此时将两边的 000 变为 111 可以获得 222 的贡献。 0 型：此时将 000 变为 111 可以获得 111 的贡献。 注意：三个类型所占用的位置不可以重复。 直接暴力找出三个类型的数量，按照上面的优先级填入即可。 Code: namespace Mr_Az&#123; int T=1; const int N=1e5+20; int n,m,res; int ans[N],c[3]; string s; inline void solve()&#123; read(n,m); cin&gt;&gt;s; s=&quot;0&quot;+s+&quot;0&quot;;// 首末填下 0 用来匹配。 for(rint i=1;i&lt;=n;i++)&#123; if(i+2&lt;=n)&#123; if(s[i-1]==&#x27;0&#x27;&amp;&amp;s[i]==&#x27;1&#x27;&amp;&amp;s[i+1]==&#x27;0&#x27;&amp;&amp;s[i+2]==&#x27;1&#x27;&amp;&amp;s[i+3]==&#x27;0&#x27;)&#123; c[0]++,i+=3; continue; &#125; &#125;// “01010” 型。 if(s[i-1]==&#x27;0&#x27;&amp;&amp;s[i]==&#x27;1&#x27;&amp;&amp;s[i+1]==&#x27;0&#x27;)&#123; c[1]++,i+=1; continue; &#125;// “010” 型。 &#125; for(rint i=1,j;i&lt;=n;i++)&#123; if(s[i]==&#x27;1&#x27;)&#123; j=i+1; while(s[j]==&#x27;1&#x27;) j++;j--; if(s[i+1]==&#x27;1&#x27;) res+=j-i+1; i=j; &#125; else c[2]++;// 0 的数量，c[2]-c[1]-c[0]= “0” 型的数量。 &#125; ans[0]=res; for(rint i=1;i&lt;=c[2];i++)&#123; if(c[0]) ans[i]=ans[i-1]+3,c[0]--; else if(c[1]) ans[i]=ans[i-1]+2,c[1]--; else ans[i]=ans[i-1]+1; &#125;// 按照优先级填入。 if(c[2]==n) ans[1]=0;// 特判一下。 for(rint i=1,x;i&lt;=m;i++) read(x),printf(&quot;%lld\\n&quot;,ans[x&gt;c[2]?c[2]:x]); return ; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"分类讨论","slug":"分类讨论","permalink":"https://volantis.js.org/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"}],"author":"Mr.Az"},{"title":"题解：P7315 [COCI 20182019 #3] Sajam","slug":"题解：P7315 [COCI 20182019 #3] Sajam","date":"2025-05-25T16:00:00.000Z","updated":"2025-05-25T16:00:00.000Z","comments":true,"path":"题解：P7315 [COCI 20182019 #3] Sajam/","permalink":"https://volantis.js.org/%E9%A2%98%E8%A7%A3%EF%BC%9AP7315%20[COCI%2020182019%20#3]%20Sajam/","excerpt":"","text":"P7315 [COCI 2018/2019 #3] Sajam 双倍经验： P10554 [ICPC 2024 Xi’an I] Turn Off The Lights。 两题差别为下表： 差别 P7315 [COCI 2018/2019 #3] Sajam P10554 [ICPC 2024 Xi’an I] Turn Off The Lights 输出方案 不需要 需要 kkk 的范围 k≤nk \\le nk≤n k&lt;nk &lt; nk&lt;n 快去偷圈！ Algorithm: 神秘观察+构造。 Solution: 令 aia_iai​ 为第 iii 行的亮灯情况，bib_ibi​ 为第 iii 行熄灯情况，两者互为补集。 对于这道题目，上来是没有头绪的，我们考虑从特殊情况开始思考。 k=0k=0k=0 的情况: 此时不能单独修改特定格子，容易发现存在合法操作方案的条件为每一行亮灯状况与第一行相同或恰好相反，O(N)O(N)O(N) 判断即可。 k&lt;nk &lt; nk&lt;n 的情况: 此时可以修改一些格子，但是由于鸽巢原理，总有一行是没有被修改的。注意到这个之后，我们只需要枚举每一行作为没有被修改的。设当前枚举第 iii 行，仿照 k=0k=0k=0 时候的方法进行判断，将每一行与 aia_iai​ 或 bib_ibi​ 取异或，这样可以找出来他们与第 iii 行不同的位置个数，对 bib_ibi​ 取异或的目的是这一行可以通过题目中的 111 操作进行取反。如果不同的位数 ≤k\\le k≤k 那么存在合法解。 k=nk=nk=n 的情况： 如果你能想出来 k&lt;nk&lt;nk&lt;n 的情况，那这个情况就非常显然了。 此时存在两种情况，对应的处理方式如下： 同上面有一行没有修改，判断同上。 所有行都只有一个位置被修改，枚举第 111 行修改的位置后，判断同上。 时间复杂度：直接暴力 O(N3)O(N^3)O(N3)，但是我们有 bitset！所以可以优化为 O(N3ω)O(\\frac{N^3}{\\omega})O(ωN3​)。 Code: namespace Mr_Az&#123; int T=1; const int N=1008; int n,k; char ch; bitset&lt;N&gt; a[N],t; inline void solve()&#123; read(n,k); for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; scanf(&quot; %c&quot;,&amp;ch); a[i][j]=ch==&#x27;o&#x27;; &#125; &#125; for(rint i=1;i&lt;=n;i++) t[i]=1; for(rint i=1;i&lt;=n;i++)&#123; int cnt=0; for(rint j=1;j&lt;=n;j++)&#123; cnt+=min((a[i]^a[j]).count(),(a[i]^t^a[j]).count()); &#125;// a[i]^t 即为 ~a[i] if(cnt&lt;=k)&#123; puts(&quot;DA&quot;); return ; &#125; &#125; if(n==k)&#123; for(rint i=1;i&lt;=n;i++)&#123; a[1].flip(i); for(rint j=2;j&lt;=n;j++)&#123; if((a[1]^a[j]).count()!=n-1&amp;&amp;(a[1]^t^a[j]).count()!=n-1) goto end; &#125; puts(&quot;DA&quot;); return ; end:; a[1].flip(i); &#125; &#125; puts(&quot;NE&quot;); return ; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"}],"author":"Mr.Az"},{"title":"P7315 [COCI 2018/2019 #3] Sajam","slug":"P7316","date":"2025-05-22T16:00:00.000Z","updated":"2025-05-22T16:00:00.000Z","comments":true,"path":"P7316/","permalink":"https://volantis.js.org/P7316/","excerpt":"","text":"P7315 [COCI 2018/2019 #3] Sajam 双倍经验： P10554 [ICPC 2024 Xi’an I] Turn Off The Lights。 两题差别为下表： 差别 P7315 [COCI 2018/2019 #3] Sajam P10554 [ICPC 2024 Xi’an I] Turn Off The Lights 输出方案 不需要 需要 kkk 的范围 k≤nk \\le nk≤n k&lt;nk &lt; nk&lt;n 快去偷圈！ Algorithm: 神秘观察+构造。 Solution: 令 aia_iai​ 为第 iii 行的亮灯情况，bib_ibi​ 为第 iii 行熄灯情况，两者互为补集。 对于这道题目，上来是没有头绪的，我们考虑从特殊情况开始思考。 k=0 的情况 此时不能单独修改特定格子，容易发现存在合法操作方案的条件为每一行亮灯状况与第一行相同或恰好相反，O(N)\\text{O}(N)O(N) 判断即可。 k&lt;n 的情况： 此时可以修改一些格子，但是由于鸽巢原理，总有一行是没有被修改的。注意到这个之后，我们只需要枚举每一行作为没有被修改的。设当前枚举第 iii 行，仿照 k=0k=0k=0 时候的方法进行判断，将每一行与 aia_iai​ 或 bib_ibi​ 取异或，这样可以找出来他们与第 iii 行不同的位置个数，对 bib_ibi​ 取异或的目的是这一行可以通过题目中的 111 操作进行取反。如果不同的位数 ≤k\\le k≤k 那么存在合法解。 k=n 的情况： 如果你能想出来 k&lt;nk&lt;nk&lt;n 的情况，那这个情况就非常显然了。 此时存在两种情况：1. 同上面有一行没有修改；2. 所有行都只有一个位置被修改。 判断同上。 枚举第 111 行修改的位置，判断同上。 时间复杂度：直接暴力 O(N3)\\text{O}(N^3)O(N3)，但是我们有 bitset！所以可以优化为 O(N3ω)\\text{O}(\\frac{N^3}{\\omega})O(ωN3​)。 Code: namespace Mr_Az&#123; int T=1; const int N=1008; int n,k; char ch; bitset&lt;N&gt; a[N],t; inline void solve()&#123; read(n,k); for(rint i=1;i&lt;=n;i++)&#123; for(rint j=1;j&lt;=n;j++)&#123; scanf(&quot; %c&quot;,&amp;ch); a[i][j]=ch==&#x27;o&#x27;; &#125; &#125; for(rint i=1;i&lt;=n;i++) t[i]=1; for(rint i=1;i&lt;=n;i++)&#123; int cnt=0; for(rint j=1;j&lt;=n;j++)&#123; cnt+=min((a[i]^a[j]).count(),(a[i]^t^a[j]).count()); &#125;// a[i]^t 即为 ~a[i] if(cnt&lt;=k)&#123; puts(&quot;DA&quot;); return ; &#125; &#125; if(n==k)&#123; for(rint i=1;i&lt;=n;i++)&#123; a[1].flip(i); for(rint j=2;j&lt;=n;j++)&#123; if((a[1]^a[j]).count()!=n-1&amp;&amp;(a[1]^t^a[j]).count()!=n-1) goto end; &#125; puts(&quot;DA&quot;); return ; end:; a[1].flip(i); &#125; &#125; puts(&quot;NE&quot;); return ; &#125; inline void mian()&#123;if(!T) read(T);while(T--) solve();&#125;&#125;","categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"bitset","slug":"bitset","permalink":"https://volantis.js.org/tags/bitset/"}],"author":"Mr.Az"},{"title":"Hello World","slug":"hello-world","date":"2025-05-15T10:50:34.171Z","updated":"2025-05-15T10:50:34.171Z","comments":true,"path":"hello-world/","permalink":"https://volantis.js.org/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new &quot;My New Post&quot; More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"editorial","slug":"editorial","permalink":"https://volantis.js.org/categories/editorial/"}],"tags":[{"name":"线段树二分","slug":"线段树二分","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BA%8C%E5%88%86/"},{"name":"根号分块","slug":"根号分块","permalink":"https://volantis.js.org/tags/%E6%A0%B9%E5%8F%B7%E5%88%86%E5%9D%97/"},{"name":"字符串","slug":"字符串","permalink":"https://volantis.js.org/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"博弈论","slug":"博弈论","permalink":"https://volantis.js.org/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"数论","slug":"数论","permalink":"https://volantis.js.org/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫队","slug":"莫队","permalink":"https://volantis.js.org/tags/%E8%8E%AB%E9%98%9F/"},{"name":"打表","slug":"打表","permalink":"https://volantis.js.org/tags/%E6%89%93%E8%A1%A8/"},{"name":"构造","slug":"构造","permalink":"https://volantis.js.org/tags/%E6%9E%84%E9%80%A0/"},{"name":"完全背包","slug":"完全背包","permalink":"https://volantis.js.org/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"},{"name":"区间 DP","slug":"区间-dp","permalink":"https://volantis.js.org/tags/%E5%8C%BA%E9%97%B4-dp/"},{"name":"模拟","slug":"模拟","permalink":"https://volantis.js.org/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://volantis.js.org/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"组合数学","slug":"组合数学","permalink":"https://volantis.js.org/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"KMP","slug":"kmp","permalink":"https://volantis.js.org/tags/kmp/"},{"name":"线段树","slug":"线段树","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"dfs 序","slug":"dfs-序","permalink":"https://volantis.js.org/tags/dfs-%E5%BA%8F/"},{"name":"数学","slug":"数学","permalink":"https://volantis.js.org/tags/%E6%95%B0%E5%AD%A6/"},{"name":"线段树优化 DP","slug":"线段树优化-dp","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96-dp/"},{"name":"动态规划 DP","slug":"动态规划-dp","permalink":"https://volantis.js.org/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-dp/"},{"name":"线段树分治","slug":"线段树分治","permalink":"https://volantis.js.org/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB/"},{"name":"最大生成树","slug":"最大生成树","permalink":"https://volantis.js.org/tags/%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"LCA","slug":"lca","permalink":"https://volantis.js.org/tags/lca/"},{"name":"树链剖分","slug":"树链剖分","permalink":"https://volantis.js.org/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"},{"name":"树形 DP","slug":"树形-dp","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2-dp/"},{"name":"贪心","slug":"贪心","permalink":"https://volantis.js.org/tags/%E8%B4%AA%E5%BF%83/"},{"name":"二进制拆位","slug":"二进制拆位","permalink":"https://volantis.js.org/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E4%BD%8D/"},{"name":"bitset","slug":"bitset","permalink":"https://volantis.js.org/tags/bitset/"},{"name":"博弈","slug":"博弈","permalink":"https://volantis.js.org/tags/%E5%8D%9A%E5%BC%88/"},{"name":"图论","slug":"图论","permalink":"https://volantis.js.org/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"分层图最短路","slug":"分层图最短路","permalink":"https://volantis.js.org/tags/%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"反悔贪心","slug":"反悔贪心","permalink":"https://volantis.js.org/tags/%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83/"},{"name":"分类讨论","slug":"分类讨论","permalink":"https://volantis.js.org/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"网络流","slug":"网络流","permalink":"https://volantis.js.org/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"二分","slug":"二分","permalink":"https://volantis.js.org/tags/%E4%BA%8C%E5%88%86/"},{"name":"离线处理","slug":"离线处理","permalink":"https://volantis.js.org/tags/%E7%A6%BB%E7%BA%BF%E5%A4%84%E7%90%86/"},{"name":"树形背包","slug":"树形背包","permalink":"https://volantis.js.org/tags/%E6%A0%91%E5%BD%A2%E8%83%8C%E5%8C%85/"},{"name":"快速幂","slug":"快速幂","permalink":"https://volantis.js.org/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"单调栈","slug":"单调栈","permalink":"https://volantis.js.org/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"}]}